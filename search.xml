<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【置顶】年度计划</title>
      <link href="/2099/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
      <url>/2099/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="What-Can-I-Do"><a href="#What-Can-I-Do" class="headerlink" title="What Can I Do?"></a>What Can I Do?</h1><h2 id="Done"><a href="#Done" class="headerlink" title="Done:"></a>Done:</h2><p>Swagger网关聚合</p><p>多数据源 基于<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>+dynamic-datasource (动态切换数据源,以及事务控制)</p><p>分库分表 基于ShardingJDBC (分片键算法实现,以及结合多数据源使用)</p><p>多数据量Excel读写 基于EasyExcel (中百万级数据量,包括java对象内存占用大小的验证)</p><p>ulisesbocchio 的 jasypt 配置文件加密</p><p>docker 不同Storage Driver的差异和特点</p><p>MyCat2(基本使用和搭建已经完成, 但是受到sql限制的影响,当前项目无法继续使用)</p><h2 id="Doing"><a href="#Doing" class="headerlink" title="Doing:"></a>Doing:</h2><p>完善ForExample项目</p><ul><li><p><input disabled="" type="checkbox"> demo1,实现类多个文件中心的存储 (alioss, minio, gitee)</p></li><li><p><input disabled="" type="checkbox"> 项目整合笔记</p></li><li><p><input disabled="" type="checkbox"> 知识点统一规范标签标记, (例如, 设计模式的使用场景,中间件的使用demo 等等)</p></li><li><p><input disabled="" type="checkbox"> 整理部署相关脚本</p></li><li><p><input disabled="" type="checkbox"> </p></li></ul><p>复合分片算法探究, 实现demo,基于用户id和时间记录用户日志</p><p>学习Arthas常规操作</p><p>搭建grafana,loki,promtail日志监控系统</p><p>读书:MySQL是怎样运行的.pdf</p><p>读书:图解数据结构.pdf</p><p>[2023&#x2F;03]K8s更多实践操作</p><p>[2023&#x2F;04]seata的对应场景实现(工作交接功能)</p><p>[2023&#x2F;04]补一篇关于&lt;函数式接口Function、Consumer、Supplier、Predicate&gt;的笔记</p><h2 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo:"></a>ToDo:</h2><p>复习一些旧知识</p><p>自封装流程引擎服务</p><p>复习并补充MQ实践操作</p><p>zerotier使用笔记</p><p>2023年9月新增短期计划:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">webFlux + netty<br><br>JXLS 实现嵌套循环模板<br><br>sftp实现&quot;阅后即焚&quot; (文件被下载后就删除)<br><br>datax更多读写数据配置<br><br>JustAuth<br><br>MyBatis-Flex,jdbcClients,JPA<br></code></pre></td></tr></table></figure><hr><h1 id="What-do-I-want-to-do"><a href="#What-do-I-want-to-do" class="headerlink" title="What do I want to do"></a>What do I want to do</h1><ul><li><p><input disabled="" type="checkbox"> 完善ForExample项目</p></li><li><p><input disabled="" type="checkbox"> 行业+岗位 常用英语词汇量补充</p></li><li><p><input disabled="" type="checkbox"> 复习前端知识,找一个合适的开源框架对接自己的Demo</p></li><li><p><input disabled="" type="checkbox"> 梳理知识体系的积累</p></li><li><p><input disabled="" type="checkbox"> 思维探索, </p><p>传达(同样的信息源,不同的理解): 目前阶段都是共享源信息,追加个人理解和判断,由上游确认或者大家共识</p><p>教学(我知道的信息快速有效传递), 类比法(用已知举例未知,low)  内容整理, 术语沿用</p><p>引导(共同未知的东西,如何引导快速获知,方法传递)  客观,实践,耐心</p></li><li><p><input disabled="" type="checkbox"> 有时间就去了解一下:</p><blockquote><p>Spring platform io bom<br>Spring IO Platform只是一个pom文件，记录了spring与其他开源项目对应的版本。省去了版本号，也就省去了处理依赖时的问题，因为Spring IO Platform中有最优的版本配置。<br>当然SpringSource为了解决这些Jar冲突，推出了各种BOM，当然最著名的就是spring platform io bom，其中最核心的三个是：spring-framework-bom、spring-boot-dependencies、platform-bom<br>项目内,参考这个思路,自定义bom管理全局依赖版本</p><p>jhipster</p><p>Mockito    Mock 对象, 便于调试</p><p>ES skip list联合索引</p></blockquote></li></ul><hr><p>岗位提升信息补齐:</p><p>自我介绍，<br>团队规模，<br>工作范围及权重：项目经理，产品（需求）<br>开发经理（技术经理），DBA，一线开发，运维</p><p>一面主要看技术实力：<br>springCloud各组件的认识，和搭配建议，常用配置。<br>分布式事务，多线程事务。<br>简单算法能力<br>中间件问题点面试题：<br>redis缓存一致性，<br>rabbitMq重复消费，丢消息补偿机制。顺序性<br>服务监控，以及JVM调优，GC频率，带来的影响。<br>MysqlSql调优。<br>集群or高可用环境的搭建和理解。<br>DevOps的搭建方案选择。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>没有那么不堪，不要妄自菲薄</title>
      <link href="/2024/05/09/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02024%E5%B9%B45%E6%9C%889%E6%97%A5/"/>
      <url>/2024/05/09/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02024%E5%B9%B45%E6%9C%889%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="没有那么不堪，不要妄自菲薄"><a href="#没有那么不堪，不要妄自菲薄" class="headerlink" title="没有那么不堪，不要妄自菲薄"></a>没有那么不堪，不要妄自菲薄</h1><p>享受存钱，<br>享受运动，<br>静心读书，<br>早睡早起，</p><p>    今天从一个博客中听到上面四个好的生活方式，发现自己已经符合其中几项，<br>存钱是我从小到大的消费观，</p><p>运动近三个月已经逐渐开始，并且接受，</p><p>读书，或许从离开校园后已经很久没有认真读书了，应该重新捡起这个习惯了，<br>早睡早起，生物钟本来就这样，哈哈。</p><p>    今年刚开始到健身房，发现很多人的体态和强度都很好，感觉自己要努力很久才能达到正常人的水平，有点自卑和惋惜。</p><p>    直到今天，我又想起了那句话:“种一个树最好的时间是十年前，其次是现在。”</p><p>    受穿越重生逆袭剧的影响，我也曾白日梦过自己回到上学时期，要求当时的自己更努力，找更准的方向。 不如当做40岁的自己现在就在我身边，告诫我要努力，才能摆脱十年后的困局或者疾病。</p><p>    加油！</p>]]></content>
      
      
      <categories>
          
          <category> 心情随记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于知识付费</title>
      <link href="/2022/01/01/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02022%E5%B9%B4%E6%9F%90%E6%9C%88/"/>
      <url>/2022/01/01/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02022%E5%B9%B4%E6%9F%90%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<h1 id="知识付费"><a href="#知识付费" class="headerlink" title="知识付费"></a>知识付费</h1><p>关于知识付费，几年前知识付费这个词就已经流行开了。我也体会过为知识付费带来的眼界和认知的开阔。但是后续并没有积极主动的为付费性知识买单。反而热衷于在开源和免费中提升自己。我思考过为什么会这样。也许是和从小到大的教育环境生活环境有关。</p><p>从小被教育，好好学习，上大学才能找好工作，才能衣食勉强无忧（20年后发现住行未必）。</p><p>在这种意识影响下长大，会形成一种因果观，因为要有钱生活，所以要学习知识。</p><p>所以，在我后来的人生中，因为我身上还穿着五年前的衣服，所以我没报名这个课程；因为我还在纠结哪个店的外卖优惠大，所以没买那本书；因为我刚刚买了房要还房贷，所以我不能够再考深造；因为我得几年内买个车接送孩子，所以我不去关注各种行业内峰会。这是对的么？这是不得不。我做不到穷其一生节衣缩食追求精神世界的提升，而阶段性的提升完全可以从非付费的知识中获取，所以这就是我自身的情况。</p><p>正常以我的性格，这段文字是不会公布于众的。但是看到现如今的互联网评论圈风气，又不由得杞人忧天，大概率会有两极分化，一方面是怒斥白嫖党的，一方面是感同身受的。我只想说：其实都对，做好你自己。</p>]]></content>
      
      
      <categories>
          
          <category> 心情随记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_Jenkins</title>
      <link href="/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Jenkins/"/>
      <url>/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Jenkins/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Jenkins"><a href="#初识Jenkins" class="headerlink" title="初识Jenkins"></a>初识Jenkins</h1><blockquote><p>这里介绍一下Hugo是什么，和我是如何接触到这个东西的。</p></blockquote><h2 id="1，下载安装Jenkins"><a href="#1，下载安装Jenkins" class="headerlink" title="1，下载安装Jenkins"></a>1，下载安装Jenkins</h2><p>（一般会根据多操作系统或者基于容器化安装，介绍多种方式）</p><h2 id="2，相关配置"><a href="#2，相关配置" class="headerlink" title="2，相关配置"></a>2，相关配置</h2><p>（一些常用的配置和操作命令记录）</p><p>maven项目配置：</p><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/Jenkins%E9%85%8D%E7%BD%AE.png" alt="Jenkins配置"></p><h2 id="3，项目中使用"><a href="#3，项目中使用" class="headerlink" title="3，项目中使用"></a>3，项目中使用</h2><p>（如果是Java开发相关的东西，会介绍一下在项目中接入的方式，依赖类库和Demo实现）</p><h2 id="4，踩过的坑"><a href="#4，踩过的坑" class="headerlink" title="4，踩过的坑"></a>4，踩过的坑</h2><p>（后续使用步骤中记录一些比较耗时的问题）</p><p>1，Jenkins 执行command脚本 提示找不到命令</p><blockquote><p>现象：Jenkins的command里面执行脚本输出找不到命令，手动登录主机可以执行。</p><p>原因及解决：Jenkins默认情况下执行shell脚本是使用非登录方式，然而非登录方式不会加载 &#x2F;etc&#x2F;profile 文件，在 Execute shell 中 添加如 #!&#x2F;bin&#x2F;bash -l 命令修改为登录方式即可解决问题，-l参数很重要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_Elasticsearch</title>
      <link href="/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/ElasticSearch/"/>
      <url>/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h1 id="初识ElasticSearch"><a href="#初识ElasticSearch" class="headerlink" title="初识ElasticSearch"></a>初识ElasticSearch</h1><blockquote><p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，可用于实现全文搜索和实时数据统计。</p></blockquote><h2 id="1，下载安装ElasticSearch"><a href="#1，下载安装ElasticSearch" class="headerlink" title="1，下载安装ElasticSearch"></a>1，下载安装ElasticSearch</h2><p>windows:</p><p>下载安装包解压。</p><p>安装ik中文分词器。</p><p>安装Kibana</p><p>Linux-docker:</p><p>下载elasticsearch镜像。</p><p>修改虚拟内存区域大小，否则会因为过小而无法启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sysctl -w vm.max_map_count=262144<br></code></pre></td></tr></table></figure><p>docker run 容器</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">docker run -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> --name elasticsearch \<br>-e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>-e <span class="hljs-string">&quot;cluster.name=elasticsearch&quot;</span> \<br>-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \<br>-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \<br>-d elasticsearch:<br></code></pre></td></tr></table></figure><p>启动时会发现&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data目录没有访问权限，只需要修改&#x2F;mydata&#x2F;elasticsearch&#x2F;data目录的权限，再重新启动。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod 777 /mydata/elasticsearch/data/<br></code></pre></td></tr></table></figure><p>安装中文分词器IKAnalyzer，并重新启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker exec -it elasticsearch /bin/bash<br><span class="hljs-meta prompt_">#</span><span class="language-bash">此命令需要在容器中运行</span><br>elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.0/elasticsearch-analysis-ik-6.4.0.zip<br>docker restart elasticsearch<br></code></pre></td></tr></table></figure><p>下载并运行kibana:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run --name kibana -p 5601:5601 \<br>--link elasticsearch:es \<br>-e &quot;elasticsearch.hosts=http://es:9200&quot; \<br>-d kibana:注意版本号一致<br></code></pre></td></tr></table></figure><h1 id="Spring-Boot中使用ElasticSearch"><a href="#Spring-Boot中使用ElasticSearch" class="headerlink" title="Spring Boot中使用ElasticSearch"></a>Spring Boot中使用ElasticSearch</h1><blockquote><p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p></blockquote><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Elasticsearch相关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="配置连接参数"><a href="#配置连接参数" class="headerlink" title="配置连接参数"></a>配置连接参数</h4><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span> <br>    <span class="hljs-attr">data:</span><br>      <span class="hljs-attr">elasticsearch:</span><br>        <span class="hljs-attr">repositories:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">cluster-nodes:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9300</span> <span class="hljs-comment"># es的连接地址及端口号</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">elasticsearch</span> <span class="hljs-comment"># es集群的名称</span><br></code></pre></td></tr></table></figure><h3 id="添加文档对象"><a href="#添加文档对象" class="headerlink" title="添加文档对象"></a>添加文档对象</h3><blockquote><p>不需要中文分词的字段设置成@Field(type &#x3D; FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer &#x3D; “ik_max_word”,type &#x3D; FieldType.Text)类型。</p></blockquote><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p>@Document</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//标示映射到Elasticsearch文档上的领域对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Document &#123;<br>  <span class="hljs-comment">//索引库名次，mysql中数据库的概念</span><br>    String <span class="hljs-title function_">indexName</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//文档类型，mysql中表的概念</span><br>    String <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//默认分片数</span><br>    <span class="hljs-type">short</span> <span class="hljs-title function_">shards</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br>  <span class="hljs-comment">//默认副本数量</span><br>    <span class="hljs-type">short</span> <span class="hljs-title function_">replicas</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Id</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表示是文档的id，文档可以认为是mysql中表行的概念</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Id &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@FieId</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Field &#123;<br>  <span class="hljs-comment">//文档中字段的类型</span><br>    FieldType <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> FieldType.Auto;<br>  <span class="hljs-comment">//是否建立倒排索引</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">index</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//是否进行存储</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">store</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">//分词器名次</span><br>    String <span class="hljs-title function_">analyzer</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为文档自动指定元数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FieldType</span> &#123;<br>    Text,<span class="hljs-comment">//会进行分词并建了索引的字符类型</span><br>    Integer,<br>    Long,<br>    Date,<br>    Float,<br>    Double,<br>    Boolean,<br>    Object,<br>    Auto,<span class="hljs-comment">//自动判断字段类型</span><br>    Nested,<span class="hljs-comment">//嵌套对象类型</span><br>    Ip,<br>    Attachment,<br>    Keyword<span class="hljs-comment">//不会进行分词建立索引的类型</span><br>可以使用衍生查询<br></code></pre></td></tr></table></figure><h4 id="Spring-Data方式操作数据"><a href="#Spring-Data方式操作数据" class="headerlink" title="Spring Data方式操作数据"></a>Spring Data方式操作数据</h4><p>继承ElasticsearchRepository接口可以获得常用的数据操作方法</p><p>可以使用衍生查询：</p><p>在接口中直接指定查询方法名称便可查询，无需进行实现，如商品表中有商品名称、标题和关键字，直接定义以下查询，就可以对这三个字段进行全文搜索。</p><p>（操作方式和MongoDB类似）</p>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从复制搭建</title>
      <link href="/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1，基于docker-部署mysql运行环境"><a href="#1，基于docker-部署mysql运行环境" class="headerlink" title="1，基于docker 部署mysql运行环境"></a>1，基于docker 部署mysql运行环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p 3306:3306 --name mysql \<br>-v /home/mydata/mysql/db:/var/lib/mysql \<br>-v /home/mydata/mysql/conf:/etc/mysql/conf.d \<br>-v /home/mydata/mysql/log:/var/log/mysql \<br>-e MYSQL_ROOT_PASSWORD=123456  \<br>--restart=always \<br>-d mysql:8.0.27 --lower_case_table_names=1 --server-id=3306<br></code></pre></td></tr></table></figure><p>同一服务器多实例的话,需要映射到不同的主机端口</p><p>命令行后面追加 –参数, 可以直接生效, 省略了后续编辑 my.cnf</p><h2 id="2，主从配置"><a href="#2，主从配置" class="headerlink" title="2，主从配置"></a>2，主从配置</h2><blockquote><p>vim &#x2F;etc&#x2F;my.cnf<br>[mysqld]<br>log-bin&#x3D;mysql-bin     &#x2F;&#x2F;[必须]启用二进制日志<br>server-id&#x3D;3306         &#x2F;&#x2F;[必须]服务器唯一ID，默认是1，</p></blockquote><p>(上面第一步使用的mysql镜像默认开启了binlog, 切用参数指定了server-id, 所以此处不用单独操作配置文件了)</p><p>用命令验证配置是否生效:</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;log_%&#x27;</span>;<br><span class="hljs-comment">-- log_bin = ON  即为开启</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@server_id</span>;<br><span class="hljs-comment">-- @@server_id = 3306 即为配置生效</span><br></code></pre></td></tr></table></figure><h2 id="3，master实例配置"><a href="#3，master实例配置" class="headerlink" title="3，master实例配置"></a>3，master实例配置</h2><p>连接主服务器mysql, 创建用于slave 连接的用户,并授权.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- // 创建普通用户，可以远程连接</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;copy&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-comment">-- // 授权slave  [grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;;]</span><br><span class="hljs-keyword">grant</span> replication slave <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;copy&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-comment">-- // 刷新权限</span><br>flush privileges;<br></code></pre></td></tr></table></figure><p>主服务器查看master状态</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> master status;<br><span class="hljs-comment">-- 查询出的File和Position字段的值 是等会在slave节点配置用到的. Position 值如果过大,说明不是初始状态,需要重置</span><br>reset master;<br><span class="hljs-comment">-- 重置后重新查询,记住有用的值</span><br>注：执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化<br></code></pre></td></tr></table></figure><h2 id="4，slave实例配置"><a href="#4，slave实例配置" class="headerlink" title="4，slave实例配置"></a>4，slave实例配置</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询slave配置, 查询为空,即为初始化状态</span><br><span class="hljs-keyword">show</span> slave status;<br><span class="hljs-comment">-- 设置从机连接主机</span><br>change master <span class="hljs-keyword">to</span> master_host<span class="hljs-operator">=</span><span class="hljs-string">&#x27;主机IP&#x27;</span>,master_user<span class="hljs-operator">=</span><span class="hljs-string">&#x27;主机刚赋予权限的用户名&#x27;</span>,master_password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;对应密码&#x27;</span>,master_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;主机状态查出的File:binlog.000001&#x27;</span>,master_log_pos<span class="hljs-operator">=</span>主机状态查出的Position:<span class="hljs-number">156</span>;<br><span class="hljs-comment">-- 执行开始复制</span><br><span class="hljs-keyword">start</span> slave;<br><span class="hljs-comment">-- 执行查看状态语句 判断是否连接成功</span><br><span class="hljs-keyword">show</span> slave status \G;<br><span class="hljs-comment">-- 如果连接异常,可通过stop slave; reset slave all; 等命令重新配置连接</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mysql&gt; show slave status \G;<br>*************************** <span class="hljs-number">1.</span> row ***************************<br>               Slave_IO_State: Waiting <span class="hljs-keyword">for</span> source to send event<br>                  Master_Host: <span class="hljs-number">121.4</span><span class="hljs-number">.99</span><span class="hljs-number">.39</span>                <span class="hljs-comment">//主服务器地址</span><br>                  Master_User: copy                          <span class="hljs-comment">//授权帐户名，尽量避免使用root</span><br>                  Master_Port: <span class="hljs-number">3306</span><span class="hljs-comment">//数据库端口,连接是没指定默认3306，部分版本没有此行</span><br>                Connect_Retry: <span class="hljs-number">60</span><br>              Master_Log_File: binlog<span class="hljs-number">.000001</span><br>          Read_Master_Log_Pos: <span class="hljs-number">156</span>      <span class="hljs-comment">//#同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos</span><br>               Relay_Log_File: 9de584ab9380-relay-bin<span class="hljs-number">.000002</span><br>                Relay_Log_Pos: <span class="hljs-number">321</span><br>        Relay_Master_Log_File: binlog<span class="hljs-number">.000001</span><br>             Slave_IO_Running: Yes                       <span class="hljs-comment">//此状态必须YES, 如果是 NO或者 Connecting,主从复制不生效,可以在下面Last_Error,Last_IO_Error,Last_SQL_Error 等相关字段根据描述排查问题</span><br>            Slave_SQL_Running: Yes                    <span class="hljs-comment">//此状态必须YES ...... 注：Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态(如：其中一个NO均属错误)。 以上操作过程，主从服务器配置完成。</span><br>              Replicate_Do_DB: <br>          Replicate_Ignore_DB: <br>           Replicate_Do_Table: <br>       Replicate_Ignore_Table: <br>      Replicate_Wild_Do_Table: <br>  Replicate_Wild_Ignore_Table: <br>                   Last_Errno: <span class="hljs-number">0</span><br>                   Last_Error: <br>                 Skip_Counter: <span class="hljs-number">0</span><br>          Exec_Master_Log_Pos: <span class="hljs-number">156</span><br>              Relay_Log_Space: <span class="hljs-number">537</span><br>              Until_Condition: None<br>               Until_Log_File: <br>                Until_Log_Pos: <span class="hljs-number">0</span><br>           Master_SSL_Allowed: No<br>           Master_SSL_CA_File: <br>           Master_SSL_CA_Path: <br>              Master_SSL_Cert: <br>            Master_SSL_Cipher: <br>               Master_SSL_Key: <br>        Seconds_Behind_Master: <span class="hljs-number">0</span><br>Master_SSL_Verify_Server_Cert: No<br>                Last_IO_Errno: <span class="hljs-number">0</span><br>                Last_IO_Error: <br>               Last_SQL_Errno: <span class="hljs-number">0</span><br>               Last_SQL_Error: <br>  Replicate_Ignore_Server_Ids: <br>             Master_Server_Id: <span class="hljs-number">1</span><br>                  Master_UUID: 3c7470a4-0739-11ed-<span class="hljs-number">9073</span>-0242ac120003<br>             Master_Info_File: mysql.slave_master_info<br>                    SQL_Delay: <span class="hljs-number">0</span><br>          SQL_Remaining_Delay: NULL<br>      Slave_SQL_Running_State: Replica has read all relay log; waiting <span class="hljs-keyword">for</span> more updates<br>           Master_Retry_Count: <span class="hljs-number">86400</span><br>                  Master_Bind: <br>      Last_IO_Error_Timestamp: <br>     Last_SQL_Error_Timestamp: <br>               Master_SSL_Crl: <br>           Master_SSL_Crlpath: <br>           Retrieved_Gtid_Set: <br>            Executed_Gtid_Set: <br>                Auto_Position: <span class="hljs-number">0</span><br>         Replicate_Rewrite_DB: <br>                 Channel_Name: <br>           Master_TLS_Version: <br>       Master_public_key_path: <br>        Get_master_public_key: <span class="hljs-number">0</span><br>            Network_Namespace: <br><span class="hljs-number">1</span> row in set, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>ERROR: <br>No query specified<br>    <br></code></pre></td></tr></table></figure><hr><p>配置完成,自行操作master数据进行验证.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 在master上查看有哪些slave</span><br><span class="hljs-keyword">show</span> slave hosts;<br><span class="hljs-comment">-- 或者</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.processlist <span class="hljs-keyword">as</span> p <span class="hljs-keyword">where</span> p.command <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Binlog Dump&#x27;</span>; <br></code></pre></td></tr></table></figure><p>如果从库是为了读写分离, 推荐在从库新建只读权限的用户,用于数据库连接.</p><p>注意:mysql出现 mysqladmin flush-hosts，是因为:</p><p>其他客户机连接错误次数过多时，mysql会禁止客户机连接.</p><p>解决方法：</p><ol><li>进入服务器数据库，打开数据库命令行界面输入flush hosts;此时便可连接</li><li>可以.修改mysql配置,添加参数max_connect_errors&#x3D;1000，设置错误次数然后重启mysql</li></ol><hr><h2 id="5，扩展-基于GTID的主从架构-目前未实践-简单记录后续补充"><a href="#5，扩展-基于GTID的主从架构-目前未实践-简单记录后续补充" class="headerlink" title="5，扩展: 基于GTID的主从架构 (目前未实践,简单记录后续补充)"></a>5，扩展: 基于GTID的主从架构 (目前未实践,简单记录后续补充)</h2><p>GTID的英文全称为Global Transaction Identifier，在MySQL主从架构中应用广泛。</p><p>GTID是由“UUID:事务号“组成的，GTID是基于事务的，在主从架构中，在主库每提交一个事务都会对应生成一个GTID号，GTID支持语句和行格式的复制，而且在主库提交的事务只会在从库应用一次，保证了一致性。</p><p><em>*<em>*</em>*一、下面说一下GTID的优缺点****</em>*</p><p><strong>1、GTID优点：</strong></p><p>①复制安全性高，搭建主从相比与传统的（基于binlog和position号）复制要简单；</p><p>②GTID在主库是连续的，保证了数据的一致性；</p><p>③故障切换时间更短，降低服务故障时间等。</p><p><strong>2、GTID缺点：</strong></p><p>①主从表存储引擎必须一致，不能一个innodb一个myisam，这样会导致主备数据不一致，因为GTID是和事务之间一一对应的；</p><p>②不允许一个sql同时更新事务引擎表和非事务引擎表；</p><p>③在主从模式下，需要主库从库同时开启和关闭gtid；</p><p>④不支持create table …. as select 语句，在主库会直接报错的；</p><p>⑤不支持create&#x2F;drop temporary table语句；</p><p>⑥不支持传统的复制模式，跳过错误的语句（sql_slave_skip_counter）。</p><p><em>*<em>*</em>*二、GTID部分相关参数介绍****</em>*</p><p>①gtid_mode：控制是否启用gtid, on&#x2F;on_permissiv&#x2F;off_perissiv&#x2F;off；</p><p>②enforce_gtid_consistency：用于保证GTID一致性的，有on&#x2F;off&#x2F;warn三个值</p><p> on：不允许任何事务违反gtid一致性；</p><p> off：允许所有事务违反gtid一致性；</p><p> warn：允许所有事务违反gtid一致性，但是这种情况下会生成告警，mysql5.7.6新增。</p><p>③gtid_executed：它是一个gtid的范围，表示的是已经执行过的所有的gtid事务集或者是由于语句人为设置的gtid。</p><p>④gtid_purged：表示的是已经执行过但是已经被purge掉的gtid，也是一个范围，它是executed的一个子集。在以下几种情况下，gtid_purged会有值：</p><p> 禁用二进制日志的情况下，提交事务的GTID；</p><p> 写入二进制日志的GTID已经被删除了；</p><p> 使用语句显示的指定gtid purged：set @@global.gtid_purged&#x3D;…。</p><p>⑤gtid_next：是会话级别的变量，对于提交的事务，会自动分配新的gtid，默认值为automatic，也可以显示指定gtid_next，来指定下一个事务的GTID号。</p><p>⑥gtid_owned：该变量主要提供内部使用，保存的是服务器上当前正在使用的所有GTID列表，以及拥有它的线程的ID。</p><p>参考文章: </p><p><a href="https://www.jb51.net/article/258847.htm">Mysql主从三种复制模式(异步复制,半同步复制,组复制)</a></p><p><a href="https://www.cnblogs.com/ordinarydba/p/16309760.html">浅谈GTID及简单测试</a></p><p><a href="http://www.qb5200.com/article/218648.html">MySql并行复制的深入浅出</a></p>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试环境搭建流程</title>
      <link href="/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="测试环境搭建流程"><a href="#测试环境搭建流程" class="headerlink" title="测试环境搭建流程"></a>测试环境搭建流程</h1><p>背景: 基于CentOS7.6, 部署一套SpringCloud开发的微服务，默认各种基础资源和中间件（GItLab，minio, Mysql，redis, rabbitMQ）已经存在</p><blockquote><p>使用脚本 初始化 宿主机</p><p><a href="os7init.sh">os7init.sh</a> </p><p>.sh os7init.sh &lt;服务器名字&gt;</p></blockquote><h2 id="0-基础准备"><a href="#0-基础准备" class="headerlink" title="0,基础准备"></a>0,基础准备</h2><p>MySQL容器启动：</p><blockquote><p>注意自定义配置文件 &#x2F;home&#x2F;mydata&#x2F;mysql&#x2F;conf&#x2F;my.cnf</p><p>[mysqld]<br>max_connections&#x3D;1000<br>sql-mode&#x3D;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p 3306:3306 --name mysql \<br>-v /home/mydata/mysql/db:/var/lib/mysql \<br>-v /home/mydata/mysql/conf:/etc/mysql/conf.d \<br>-v /home/mydata/mysql/log:/var/log/mysql \<br>-e MYSQL_ROOT_PASSWORD=Ewit@123  \<br>--restart=always \<br>-d mysql:8.0.27 --lower_case_table_names=1 --server-id=3306<br></code></pre></td></tr></table></figure><p>Redis容器启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p 6379:6379 --name redis \<br>-v /home/mydata/redis/data:/data \<br>--restart=always \<br>-d redis:6.2.6 redis-server --appendonly yes<br></code></pre></td></tr></table></figure><p>minio文件服务器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p 9001:9001 -p 9000:9000 \<br>--net=host \<br>--name minio \<br>-d --restart=always \<br>-e &quot;MINIO_ACCESS_KEY=sip&quot; \<br>-e &quot;MINIO_SECRET_KEY=Ewit@123&quot; \<br>-v /mydata/minio/data:/data \<br>-v /mydata/minio/config:/root/.minio \<br>minio/minio server \<br>/data --console-address &quot;:9001&quot; -address &quot;:9000&quot;<br></code></pre></td></tr></table></figure><p>nacos：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name nacos -p 8848:8848 \<br>--env MODE=standalone \<br>--env JVM_XMS=256m \<br>--env JVM_XMX=256m \<br>--env JVM_XMN=128m \<br>--env SPRING_DATASOURCE_PLATFORM=mysql \<br>--env MYSQL_SERVICE_HOST=192.168.2.110 \<br>--env MYSQL_SERVICE_PORT=3306 \<br>--env MYSQL_SERVICE_DB_NAME=gz_cby_config \<br>--env MYSQL_SERVICE_USER=root \<br>--env MYSQL_SERVICE_PASSWORD=Ewit@123\<br> nacos/nacos-server:v2.1.1-slim<br></code></pre></td></tr></table></figure><h2 id="1，宿主机环境安装"><a href="#1，宿主机环境安装" class="headerlink" title="1，宿主机环境安装"></a>1，宿主机环境安装</h2><blockquote><p>下载可以从官网或者<a href="https://mirrors.huaweicloud.com/home">华为云镜像</a>下载，包放置服务器&#x2F;home目录</p><p>下载openJDK11 ，Maven3.6.3  NodeJs14.18.1</p><p>解压（解压后文件可以改名，如果改了名，后面路径记得修改）</p><p>tar -zxvf openjdk-11.0.2_linux-x64_bin.tar.gz</p><p>tar -zxvf apache-maven-3.6.3-bin.tar.gz</p><p>tar -zxvf node-v14.18.1-linux-x64.tar.gz</p></blockquote><p>修改环境变量（环境变量是可以在全局使用bin下面的命令，可以也用软连接方式做）</p><ul><li><p>添加进系统环境变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vim /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>文件内容追加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># java<br>export JAVA_HOME=/home/jdk-11.0.2<br>export JRE_HOME=$JAVA_HOME/jre<br>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH<br>export PATH=$JAVA_HOME/bin:$PATH<br># maven<br>export MAVEN_HOME=/home/apache-maven-3.6.3<br>export PATH=$PATH:$MAVEN_HOME/bin<br># nodejs<br>export NODEJS=/home/node-v14.18.1<br>export PATH=$NODEJS/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p>环境变量生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">source /etc/profile<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-安装Docker环境"><a href="#2-安装Docker环境" class="headerlink" title="2, 安装Docker环境"></a>2, 安装Docker环境</h2><ul><li><p>安装yum-utils：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure></li><li><p>为yum源添加docker仓库位置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>安装docker：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum install docker-ce<br></code></pre></td></tr></table></figure></li><li><p>启动docker：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-1-修改docker安装路径"><a href="#2-1-修改docker安装路径" class="headerlink" title="2.1, 修改docker安装路径"></a>2.1, 修改docker安装路径</h3><p>停掉Docker服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">systemctl stop docker<br></code></pre></td></tr></table></figure><p>根据上面查到的路径，移动整个<code>/var/lib/docker</code>目录到数据盘的目的路径)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cp -arf /var/lib/docker /home/<br></code></pre></td></tr></table></figure><p>修改配置默认路径</p><p>在EXECStart后面添加<code>--data-root=/home/docker</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vim /usr/lib/systemd/system/docker.service<br><br># ExecStart=/usr/bin/dockerd --data-root=/home/docker<br></code></pre></td></tr></table></figure><p>刷新配置,重启docker</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">systemctl daemon-reload<br>systemctl start docker<br></code></pre></td></tr></table></figure><p>查看docker数据存储目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker info | grep &quot;Docker Root Dir&quot;<br><br># Docker Root Dir: /home/docker<br></code></pre></td></tr></table></figure><p>docker images 确认之前的镜像是否还在</p><p>通过上述方法完成迁移之后，在确认 Docker 能正常工作之后，删除原目录数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure><h2 id="3-安装jenkins"><a href="#3-安装jenkins" class="headerlink" title="3,安装jenkins"></a>3,安装jenkins</h2><blockquote><p>本机安装jenkins 以便于实现CI&#x2F;CD，打包仓库隔离，jenkins部署在docker中，不在容器内额外安装过多环境，可以挂载宿主机的 jdk maven nodejs等,  可以使用命令软连接，包装shell中可以执行命令</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 10000:8080 -p 10001:50000 \<br>-v /home/jenkins/jenkins_home:/var/jenkins_home \<br>-v /home/jdk-11.0.2:/usr/local/jdk \<br>-v /home/apache-maven-3.6.3:/usr/local/maven \<br>-v /home/node-v14.18.1:/usr/local/node \<br>-v /var/run/docker.sock:/var/run/docker.sock \<br>-v /usr/bin/docker:/usr/bin/docker \<br>-v /etc/localtime:/etc/localtime \<br>-u root \<br>--privileged=true \<br>--name jenkins jenkins/jenkins<br></code></pre></td></tr></table></figure><blockquote><p>建立软连接</p><p>ln -s &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;<br>ln -s &#x2F;usr&#x2F;local&#x2F;maven&#x2F;bin&#x2F;* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;<br>ln -s &#x2F;usr&#x2F;local&#x2F;node&#x2F;bin&#x2F;* &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</p><p>node如果配置私服，需要添加认证信息 vi ~&#x2F;.npmrc</p></blockquote><p>docker容器内如果没有vim命令 可以 自行安装 </p><p>apt update</p><p>apt install vim</p><p>jenkins 部署完毕，初始化及使用方式配置过程，可以参考另外的笔记 <a href="https://duo-ge.gitee.io/p/jenkins/%E3%80%82">https://duo-ge.gitee.io/p/jenkins/。</a></p><p>注意：初始化插件检测失败时可以后续手动安装必须插件，安装前进入<a href="http://172.16.80.50:10000/manage/pluginManager/advanced">配置页</a>替换插件升级站点：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p><h2 id="4-部署nacos-如果和其他环境共用nacos，可以不装"><a href="#4-部署nacos-如果和其他环境共用nacos，可以不装" class="headerlink" title="4,部署nacos (如果和其他环境共用nacos，可以不装)"></a>4,部署nacos (如果和其他环境共用nacos，可以不装)</h2><blockquote><p>docker部署nacos,配置参数变量，单节点，指定mysql做配置数据持久化</p><p>数据库备份  <a href="cby_config.sql">cby_config.sql</a> </p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name nacos -p 8848:8848 \<br>--env MODE=standalone \<br>--env JVM_XMS=256m \<br>--env JVM_XMX=256m \<br>--env JVM_XMN=128m \<br>--env SPRING_DATASOURCE_PLATFORM=mysql \<br>--env MYSQL_SERVICE_HOST=172.16.80.50 \<br>--env MYSQL_SERVICE_PORT=3306 \<br>--env MYSQL_SERVICE_DB_NAME=cby_config \<br>--env MYSQL_SERVICE_USER=root \<br>--env MYSQL_SERVICE_PASSWORD=Ewit@123\<br> nacos/nacos-server:v2.1.0-slim<br></code></pre></td></tr></table></figure><h2 id="5，Nginx安装（按需而定）"><a href="#5，Nginx安装（按需而定）" class="headerlink" title="5，Nginx安装（按需而定）"></a>5，Nginx安装（按需而定）</h2><ul><li><p>下载Nginx的docker镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull nginx<br></code></pre></td></tr></table></figure></li><li><p>先运行一次容器（为了拷贝配置文件）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -p 80:80 --name nginx \<br>-v /mydata/nginx/html:/usr/share/nginx/html \<br>-v /mydata/nginx/logs:/var/log/nginx  \<br>-d nginx<br></code></pre></td></tr></table></figure></li><li><p>将容器内的配置文件拷贝到指定目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">cp</span> nginx:/etc/nginx /mydata/nginx/<br></code></pre></td></tr></table></figure></li><li><p>修改文件名称：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /mydata/nginx<br><span class="hljs-built_in">mv</span> nginx conf<br></code></pre></td></tr></table></figure></li><li><p>终止并删除容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker stop nginx<br>docker <span class="hljs-built_in">rm</span> nginx<br></code></pre></td></tr></table></figure></li><li><p>使用如下命令启动Nginx服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -p 80:80 -p 443:443 -p 8080:8080 --name nginx \<br>-v /mydata/nginx/html:/usr/share/nginx/html \<br>-v /mydata/nginx/logs:/var/log/nginx  \<br>-v /mydata/nginx/conf:/etc/nginx \<br>-d nginx<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>最终运行命令的端口映射根据需要增加，端口没有映射到宿主机，增加了配置文件也无法从外部访问</p><p>Docker部署这个nginx 这里基本是为了实现反向代理</p><p>所以补充配置文件在 &#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d里面就可以了， 案例如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">server &#123;<br>    listen       80;<br><br>    location / &#123;           <br>proxy_pass http://192.168.1.60:9009;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="限制docker容器内存上限"><a href="#限制docker容器内存上限" class="headerlink" title="限制docker容器内存上限"></a>限制docker容器内存上限</h2><p>1 启动容器时限制容器内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker run -m 4g --memory-swap -1<br></code></pre></td></tr></table></figure><p>2 限制已启动容器的内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker stop containerId<br>docker update containerId -m 6g  --memory-swap -1<br>docker start containerId<br></code></pre></td></tr></table></figure><p>备注：命令详解</p><blockquote><p>–memory  或  -m  限制容器的内存使用量（如10m,200m等）<br>–memory-swap # 限制内存和 Swap 的总和，不设置的话默认为–memory的两倍</p><p>如果只指定了 –memory 则 –memory-swap 默认为 –memory 的两倍<br>如果 –memory-swap 和 –memory 设置了相同值，则表示不使用 Swap<br>如果 –memory-swap 设置为 -1 则表示不对容器使用的 Swap 进行限制<br>如果设置了 –memory-swap 参数，则必须设置 –memory 参数<br>后期 update –memory 时数值不能超过 –memory-swap 的值，否则会报错 Memory limit should be smaller than already set memoryswap limit</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_seata</title>
      <link href="/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/seata/"/>
      <url>/2021/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/seata/</url>
      
        <content type="html"><![CDATA[<h1 id="初识seata"><a href="#初识seata" class="headerlink" title="初识seata"></a>初识seata</h1><blockquote><p><a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata了解</a></p><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><h2 id="1，基于docker安装seata"><a href="#1，基于docker安装seata" class="headerlink" title="1，基于docker安装seata"></a>1，基于docker安装seata</h2><p>1,拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker pull seataio/seata-server:1.6.1<br></code></pre></td></tr></table></figure><p>2,运行初始容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker run -d --name seata -p 8091:8091 seataio/seata-server:1.6.1<br></code></pre></td></tr></table></figure><p>3,创建挂载目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mkdir  /mydata/seata<br></code></pre></td></tr></table></figure><p>4,将容器内配置文件拷贝到挂载目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker cp seata:/seata-server  /mydata/seata<br></code></pre></td></tr></table></figure><p>5,修改配置文件</p><p>在 &#x2F;mydata&#x2F;seata&#x2F;seata-server&#x2F;resources目录内找到配置文件.</p><p>修改配置文件application.yml 可参考application.example.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7091</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-server</span><br><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">config:</span> <span class="hljs-string">classpath:logback-spring.xml</span><br>  <span class="hljs-attr">file:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">$&#123;user.home&#125;/logs/seata</span><br>  <span class="hljs-attr">extend:</span><br>    <span class="hljs-attr">logstash-appender:</span><br>      <span class="hljs-attr">destination:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:4560</span><br>    <span class="hljs-attr">kafka-appender:</span><br>      <span class="hljs-attr">bootstrap-servers:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9092</span><br>      <span class="hljs-attr">topic:</span> <span class="hljs-string">logback_to_logstash</span><br><br><span class="hljs-attr">console:</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">seata</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">seata</span><br><br><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-comment"># support: nacos, consul, apollo, zk, etcd3</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.61</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">local</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">SEATA_GROUP</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">context-path:</span><br>      <span class="hljs-attr">data-id:</span> <span class="hljs-string">seataServer.properties</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-comment"># support: nacos, eureka, redis, zk, consul, etcd3, sofa</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">preferred-networks:</span> <span class="hljs-number">192.168</span><span class="hljs-string">.*</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">application:</span> <span class="hljs-string">seata-server</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.61</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">SEATA_GROUP</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">local</span><br>      <span class="hljs-attr">cluster:</span> <span class="hljs-string">default</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">context-path:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-string">SeataSecretKey0c382ef121d778043159209298fd40bf3850a017</span><br>    <span class="hljs-attr">tokenValidityInMilliseconds:</span> <span class="hljs-number">1800000</span><br>    <span class="hljs-attr">ignore:</span><br>      <span class="hljs-attr">urls:</span> <span class="hljs-string">/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/api/v1/auth/login</span><br></code></pre></td></tr></table></figure><p>nacos中对应local命名空间,SEATA_GROUP配置文件:<a href="https://github.com/seata/seata/blob/2.x/script/config-center/config.txt">seataServer.properties</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#For details about configuration items, see https://seata.io/zh-cn/docs/user/configurations.html<br>#Transport configuration, for client and server<br>transport.type=TCP<br>transport.server=NIO<br>transport.heartbeat=true<br>transport.enableTmClientBatchSendRequest=false<br>transport.enableRmClientBatchSendRequest=true<br>transport.enableTcServerBatchSendResponse=false<br>transport.rpcRmRequestTimeout=30000<br>transport.rpcTmRequestTimeout=30000<br>transport.rpcTcRequestTimeout=30000<br>transport.threadFactory.bossThreadPrefix=NettyBoss<br>transport.threadFactory.workerThreadPrefix=NettyServerNIOWorker<br>transport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandler<br>transport.threadFactory.shareBossWorker=false<br>transport.threadFactory.clientSelectorThreadPrefix=NettyClientSelector<br>transport.threadFactory.clientSelectorThreadSize=1<br>transport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThread<br>transport.threadFactory.bossThreadSize=1<br>transport.threadFactory.workerThreadSize=default<br>transport.shutdown.wait=3<br>transport.serialization=seata<br>transport.compressor=none<br><br>#Transaction routing rules configuration, only for the client<br>service.vgroupMapping.default_tx_group=default<br>#If you use a registry, you can ignore it<br>service.default.grouplist=192.168.1.61:8091<br>service.enableDegrade=false<br>service.disableGlobalTransaction=false<br><br>#Transaction rule configuration, only for the client<br>client.rm.asyncCommitBufferLimit=10000<br>client.rm.lock.retryInterval=10<br>client.rm.lock.retryTimes=30<br>client.rm.lock.retryPolicyBranchRollbackOnConflict=true<br>client.rm.reportRetryCount=5<br>client.rm.tableMetaCheckEnable=true<br>client.rm.tableMetaCheckerInterval=60000<br>client.rm.sqlParserType=druid<br>client.rm.reportSuccessEnable=false<br>client.rm.sagaBranchRegisterEnable=false<br>client.rm.sagaJsonParser=fastjson<br>client.rm.tccActionInterceptorOrder=-2147482648<br>client.tm.commitRetryCount=5<br>client.tm.rollbackRetryCount=5<br>client.tm.defaultGlobalTransactionTimeout=60000<br>client.tm.degradeCheck=false<br>client.tm.degradeCheckAllowTimes=10<br>client.tm.degradeCheckPeriod=2000<br>client.tm.interceptorOrder=-2147482648<br>client.undo.dataValidation=true<br>client.undo.logSerialization=fastjson<br>client.undo.onlyCareUpdateColumns=true<br>server.undo.logSaveDays=7<br>server.undo.logDeletePeriod=86400000<br>client.undo.logTable=undo_log<br>client.undo.compress.enable=true<br>client.undo.compress.type=zip<br>client.undo.compress.threshold=64k<br>#For TCC transaction mode<br>tcc.fence.logTableName=tcc_fence_log<br>tcc.fence.cleanPeriod=1h<br># You can choose from the following options: fastjson, jackson, gson<br>tcc.contextJsonParserType=fastjson<br><br>#Log rule configuration, for client and server<br>log.exceptionRate=100<br><br>#Transaction storage configuration, only for the server. The file, db, and redis configuration values are optional.<br>store.mode=db<br>store.lock.mode=db<br>store.session.mode=db<br><br>#These configurations are required if the `store mode` is `db`. If `store.mode,store.lock.mode,store.session.mode` are not equal to `db`, you can remove the configuration block.<br>store.db.datasource=druid<br>store.db.dbType=mysql<br>store.db.driverClassName=com.mysql.jdbc.Driver<br>store.db.url=jdbc:mysql://192.168.1.61:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true<br>store.db.user=root<br>store.db.password=Ewit@123<br>store.db.minConn=5<br>store.db.maxConn=30<br>store.db.globalTable=global_table<br>store.db.branchTable=branch_table<br>store.db.distributedLockTable=distributed_lock<br>store.db.queryLimit=100<br>store.db.lockTable=lock_table<br>store.db.maxWait=5000<br><br>#Transaction rule configuration, only for the server<br>server.recovery.committingRetryPeriod=1000<br>server.recovery.asynCommittingRetryPeriod=1000<br>server.recovery.rollbackingRetryPeriod=1000<br>server.recovery.timeoutRetryPeriod=1000<br>server.maxCommitRetryTimeout=-1<br>server.maxRollbackRetryTimeout=-1<br>server.rollbackRetryTimeoutUnlockEnable=false<br>server.distributedLockExpireTime=10000<br>server.xaerNotaRetryTimeout=60000<br>server.session.branchAsyncQueueSize=5000<br>server.session.enableBranchAsyncRemove=false<br>server.enableParallelRequestHandle=false<br><br>#Metrics configuration, only for the server<br>metrics.enabled=false<br>metrics.registryType=compact<br>metrics.exporterList=prometheus<br>metrics.exporterPrometheusPort=9898<br></code></pre></td></tr></table></figure><p>如果store使用db, 需要建对应的数据库并初始化建表.seata源码中有对应<a href="https://github.com/seata/seata/blob/2.x/script/server/db/mysql.sql">sql脚本</a></p><p>6,停掉并清除旧容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker stop seata<br> <br>docker rm seata<br></code></pre></td></tr></table></figure><p>7,挂载目录重新运行容器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker run --name seata \<br>--restart always \<br>-p 8091:8091 \<br>-v /mydata/seata/seata-server:/seata-server \<br>-e SEATA_IP=192.168.1.61 \<br>-e SEATA_PORT=8091 \<br>-d seataio/seata-server:1.6.1<br></code></pre></td></tr></table></figure><p>8,通过docker logs 或者 nacos 确认seata运行成功</p><p>9,AT模式建表</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `undo_log`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;increment id&#x27;</span>,<br>  `branch_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;branch transaction id&#x27;</span>,<br>  `xid` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;global transaction id&#x27;</span>,<br>  `context` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;undo_log context,such as serialization&#x27;</span>,<br>  `rollback_info` longblob <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;rollback info&#x27;</span>,<br>  `log_status` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;0:normal status,1:defense status&#x27;</span>,<br>  `log_created` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;create datetime&#x27;</span>,<br>  `log_modified` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;modify datetime&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">99</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;AT transaction mode undo table&#x27;</span>;<br><span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="2，使用seata"><a href="#2，使用seata" class="headerlink" title="2，使用seata"></a>2，使用seata</h2><p><a href="https://github.com/seata/seata-samples">官方案例</a></p><p>1,添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2, 业务服务添加配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># seata 分布式事务配置</span><br><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">application-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span><br>  <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">default_tx_group</span><br>  <span class="hljs-attr">enable-auto-data-source-proxy:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">data-source-proxy-mode:</span> <span class="hljs-string">AT</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.61</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">local</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">SEATA_GROUP</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">data-id:</span> <span class="hljs-string">seataServer.properties</span><br></code></pre></td></tr></table></figure><p>另外如果使用了 dynamic-datasource.  对应的seata配置也要为true</p><p>3,代码  以 A 方法内 调用 B和 C 为例. (A,B,C 实际会是不同服务里的不同方法)</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GlobalTransactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>    B();<br>    C();<br>&#125;<br><br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 模拟sql update</span><br>&#125;<br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">C</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 方法内报错, B中的sql会回滚</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3，可能的坑"><a href="#3，可能的坑" class="headerlink" title="3，可能的坑"></a>3，可能的坑</h2><p>1.4.2版本序列化可能有问题, 所以 seata-spring-boot-starter 尽量使用新版本(当前1.6.1)</p><h2 id="4，结合sharding-jdbc使用"><a href="#4，结合sharding-jdbc使用" class="headerlink" title="4，结合sharding-jdbc使用"></a>4，结合sharding-jdbc使用</h2><p><a href="https://github.com/seata/seata-samples/tree/master/springcloud-seata-sharding-jdbc-mybatis-plus-samples">官方demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql常用运维统计语句</title>
      <link href="/2021/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Mysql%E5%B8%B8%E7%94%A8%E8%BF%90%E7%BB%B4%E7%BB%9F%E8%AE%A1%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Mysql%E5%B8%B8%E7%94%A8%E8%BF%90%E7%BB%B4%E7%BB%9F%E8%AE%A1%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1，Mysql查询数据磁盘占用量"><a href="#1，Mysql查询数据磁盘占用量" class="headerlink" title="1，Mysql查询数据磁盘占用量"></a>1，Mysql查询数据磁盘占用量</h2><p>1.查看所有数据库容量大小</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>table_schema <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数据库&#x27;</span>,<br><span class="hljs-built_in">sum</span>(table_rows) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;记录数&#x27;</span>,<br><span class="hljs-built_in">sum</span>(<span class="hljs-keyword">truncate</span>(data_length<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>, <span class="hljs-number">2</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数据容量(MB)&#x27;</span>,<br><span class="hljs-built_in">sum</span>(<span class="hljs-keyword">truncate</span>(index_length<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>, <span class="hljs-number">2</span>)) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;索引容量(MB)&#x27;</span><br><span class="hljs-keyword">from</span> information_schema.tables<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> table_schema<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">sum</span>(data_length) <span class="hljs-keyword">desc</span>, <span class="hljs-built_in">sum</span>(index_length) <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>2.查看所有数据库各表容量大小</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>table_schema <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数据库&#x27;</span>,<br>table_name <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;表名&#x27;</span>,<br>table_rows <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;记录数&#x27;</span>,<br><span class="hljs-keyword">truncate</span>(data_length<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;数据容量(MB)&#x27;</span>,<br><span class="hljs-keyword">truncate</span>(index_length<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;索引容量(MB)&#x27;</span><br><span class="hljs-keyword">from</span> information_schema.tables<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> data_length <span class="hljs-keyword">desc</span>, index_length <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>3.查看指定数据库容量大小</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select <br>table_schema as &#x27;数据库&#x27;,<br>sum(table_rows) as &#x27;记录数&#x27;,<br>sum(truncate(data_length/1024/1024, 2)) as &#x27;数据容量(MB)&#x27;,<br>sum(truncate(index_length/1024/1024, 2)) as &#x27;索引容量(MB)&#x27;<br>from information_schema.tables<br>where table_schema=&#x27;mysql&#x27;;<br></code></pre></td></tr></table></figure><h2 id="2，Mysql获取近期数据统计"><a href="#2，Mysql获取近期数据统计" class="headerlink" title="2，Mysql获取近期数据统计"></a>2，Mysql获取近期数据统计</h2><h3 id="MySql获取最近一天、一周、一月数据进行统计分析"><a href="#MySql获取最近一天、一周、一月数据进行统计分析" class="headerlink" title="MySql获取最近一天、一周、一月数据进行统计分析"></a>MySql获取最近一天、一周、一月数据进行统计分析</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询今天数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">where</span> to_days(时间字段名) <span class="hljs-operator">=</span> to_days(now());<br><br><span class="hljs-comment">-- 查询昨天数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <br><span class="hljs-keyword">WHERE</span> to_days(now()) <span class="hljs-operator">-</span> to_days( 时间字段名) <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1</span><br><br><span class="hljs-comment">-- 查询最近7天数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <br><span class="hljs-keyword">where</span> DATE_SUB(CURDATE(), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>) <span class="hljs-operator">&lt;=</span> <span class="hljs-type">date</span>(时间字段名)<br><br><span class="hljs-comment">-- 查询本周的数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">WHERE</span> YEARWEEK(date_format(submittime,<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)) <span class="hljs-operator">=</span> YEARWEEK(now());<br><br><span class="hljs-comment">-- 查询上周的数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <br><span class="hljs-keyword">WHERE</span> YEARWEEK(date_format(submittime,<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)) <span class="hljs-operator">=</span> YEARWEEK(now())<span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">-- 查询本月数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <br><span class="hljs-keyword">WHERE</span> DATE_FORMAT( 时间字段名, <span class="hljs-string">&#x27;%Y%m&#x27;</span> ) <span class="hljs-operator">=</span> DATE_FORMAT( CURDATE( ) , <span class="hljs-string">&#x27;%Y%m&#x27;</span> );<br><br><span class="hljs-comment">-- 查询上一月的数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 <br><span class="hljs-keyword">WHERE</span> PERIOD_DIFF( date_format( now( ) , <span class="hljs-string">&#x27;%Y%m&#x27;</span> ) , date_format( 时间字段名, <span class="hljs-string">&#x27;%Y%m&#x27;</span> ) ) <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 查询本季度数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">where</span> QUARTER(create_date)<span class="hljs-operator">=</span>QUARTER(now());<br><br><span class="hljs-comment">-- 查询上季度数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">where</span> QUARTER(create_date)<span class="hljs-operator">=</span>QUARTER(DATE_SUB(now(),<span class="hljs-type">interval</span> <span class="hljs-number">1</span> QUARTER));<br><br><span class="hljs-comment">-- 查询本年数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">YEAR</span>(create_date)<span class="hljs-operator">=</span><span class="hljs-keyword">YEAR</span>(NOW());<br><br><span class="hljs-comment">-- 查询上年数据</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span>(create_date)<span class="hljs-operator">=</span><span class="hljs-keyword">year</span>(date_sub(now(),<span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">year</span>));<br></code></pre></td></tr></table></figure><h2 id="3，Mysql批量修改字符集"><a href="#3，Mysql批量修改字符集" class="headerlink" title="3，Mysql批量修改字符集"></a>3，Mysql批量修改字符集</h2><h4 id="修改数据库字符集："><a href="#修改数据库字符集：" class="headerlink" title="修改数据库字符集："></a>修改数据库字符集：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> DATABASE `库名` <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-string">&#x27;utf8mb4&#x27;</span> <span class="hljs-keyword">COLLATE</span> <span class="hljs-string">&#x27;utf8mb4_general_ci&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="修改数据表字符集："><a href="#修改数据表字符集：" class="headerlink" title="修改数据表字符集："></a>修改数据表字符集：</h4><p><strong>（执行以下语句，将查询结果复制出来执行，遇到错误跳过即可）</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;ALTER TABLE `&#x27;</span>, TABLE_SCHEMA, <span class="hljs-string">&#x27;`.`&#x27;</span>, TABLE_NAME, <span class="hljs-string">&#x27;` CHARACTER SET = utf8mb4, COLLATE = utf8mb4_general_ci;&#x27;</span>) <span class="hljs-keyword">AS</span> `sql_command`<br><span class="hljs-keyword">FROM</span> information_schema.`TABLES`<br><span class="hljs-keyword">WHERE</span> `TABLE_SCHEMA` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;库名&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><h4 id="修改字段字符集："><a href="#修改字段字符集：" class="headerlink" title="修改字段字符集："></a>修改字段字符集：</h4><p><strong>（执行以下语句，将查询结果复制出来执行，遇到错误跳过即可）</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>CONCAT(<br>    <span class="hljs-string">&#x27;ALTER TABLE `&#x27;</span>, TABLE_SCHEMA, <span class="hljs-string">&#x27;`.`&#x27;</span>, TABLE_NAME, <br>    <span class="hljs-string">&#x27;` MODIFY COLUMN `&#x27;</span>, COLUMN_NAME, <span class="hljs-string">&#x27;` &#x27;</span>, COLUMN_TYPE, <br>    <span class="hljs-string">&#x27; CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci &#x27;</span>,<br>    IF(IS_NULLABLE <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;YES&#x27;</span>, CONCAT(<span class="hljs-string">&#x27;NULL DEFAULT &#x27;</span>, IF(`COLUMN_DEFAULT` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;NULL &#x27;</span>, CONCAT(<span class="hljs-string">&#x27;&quot;&#x27;</span>, COLUMN_DEFAULT, <span class="hljs-string">&#x27;&quot; &#x27;</span>))), <span class="hljs-string">&#x27;NOT NULL &#x27;</span>),<br>    <span class="hljs-string">&#x27;COMMENT \&#x27;&#x27;, COLUMN_COMMENT, &#x27;</span>\<span class="hljs-string">&#x27;;&#x27;</span><br>) <span class="hljs-keyword">AS</span> `sql_command`<br><span class="hljs-keyword">FROM</span> information_schema.`COLUMNS`<br><span class="hljs-keyword">WHERE</span> `TABLE_SCHEMA` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;库名&#x27;</span> <span class="hljs-keyword">AND</span> (DATA_TYPE <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;varchar&#x27;</span> <span class="hljs-keyword">OR</span> DATA_TYPE <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;char&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基础命令图示</title>
      <link href="/2021/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%9B%BE%E7%A4%BA/"/>
      <url>/2021/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E5%9B%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Purr-Git-Explained-with-Cats"><a href="#Git-Purr-Git-Explained-with-Cats" class="headerlink" title="Git Purr - Git Explained with Cats!"></a>Git Purr - Git Explained with Cats!</h1><p>This series is my ealier work and everything is drawn in a very analog way, except cherry-pick</p><h2 id="git-purr-git-pull"><a href="#git-purr-git-pull" class="headerlink" title="git purr (git pull)"></a>git purr (git pull)</h2><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/git-purr.jpg" alt="Git pull explained with cats"></p><h2 id="git-meowge-git-merge-git-rebase"><a href="#git-meowge-git-merge-git-rebase" class="headerlink" title="git meowge (git merge &amp; git rebase)"></a>git meowge (git merge &amp; git rebase)</h2><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/git-meowge.jpg" alt="Git merge explained with cats"></p><h2 id="git-puss-git-push"><a href="#git-puss-git-push" class="headerlink" title="git puss (git push)"></a>git puss (git push)</h2><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/git-puss.jpg" alt="Git push explained with cats"></p><h2 id="git-cherry-pick-git-log"><a href="#git-cherry-pick-git-log" class="headerlink" title="git cherry-pick &amp; git log"></a>git cherry-pick &amp; git log</h2><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/git-cherry-pick.jpg" alt="Git cherry-pick explained with cats"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老程序员给初学者的一些建议和忠告</title>
      <link href="/2021/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%80%81%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%99%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%E5%92%8C%E5%BF%A0%E5%91%8A/"/>
      <url>/2021/01/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%80%81%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%99%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%E5%92%8C%E5%BF%A0%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="老程序员给初学者的一些建议和忠告"><a href="#老程序员给初学者的一些建议和忠告" class="headerlink" title="老程序员给初学者的一些建议和忠告"></a>老程序员给初学者的一些建议和忠告</h1><p>我始终认为，对一个初学者来说，IT界的技术风潮是不可追赶的。我时常看见自己的学弟学妹们把课本扔了，去买些价格不菲的诸如C#、VB.Net这样的大部头，这让我感到非常痛心。而许多搞不清指针是咋回事的BBS站友眉飞色舞的讨论C#里面可以不用指针等等则让我觉得好笑。</p><p>C#就象当年的ASP一样，犹如：“忽如一夜春风来，千树万树梨花开”，结果许多学校的信息学院成了“Web学院”。不少大学生也都跟着去做Web了。当然我没有任何歧视某一行业的意识，我只是觉得如果他们把追赶这些时髦技术的时间多花一点在基础的课程上应该是可以走得更远的。在此，我就借助马海祥博客的平台用一些实际的例子来说明这些现象，同时也给初学者的一些建议和忠告：</p><p>老程序员给初学者的一些建议和忠告-马海祥博客</p><p>1、计算机技术并不等于编程技术</p><p>有些人即使没有这个想法，在潜意识中也有这样的冲动。让马海祥觉得奇怪的是，许多信息学院的学生也有这样的念头，认为计算机专业就是编程专业，与编程无关的，或者不太相关课程他统统都不管，极端的学生只要书上没带“编程”两个字他就不看（具体可通过马海祥博客的《12种最常用的网页编程语言简介》相关介绍来详细了解）。</p><p>其实编程只是计算机技术应用过程中一种复杂性最低的劳动，这就是为什么IT业最底层的人是程序员（CODER）。计算机技术包括了多媒体，计算机网络，人工智能，模式识别，管理信息系统等等这些方面。</p><p>编程工作只是在这些具体技术在理论研究或者工程实践的过程中表达算法的过程，编程的人不一定对计算机技术的了解就一定很高，而一个有趣的现象是，不少大师级的计算机技术研究者是不懂编程的，只是网上的炒作和现实中良好的工作待遇把编程这种劳动神秘化了。</p><p>其实每一个程序员心里都明白，自己这些东西，学的时候并不比其它专业难，所以自然也不会高档到哪里去。</p><p>2、避免咬文嚼字的作风</p><p>我见过一本女生的《计算机网络原理》教材，这个女生像小学生一样在书上划满了横杠杠，笔记做得满满的，打印出来一定比教材还厚。马海祥不明白的是，像计算机网络原理这样的课程有必要做笔记？我们的应试教育的确害了不少学生，在上《原理》这一类课程的时候许多学生像学《马列原理》一样逐字背诵记忆。这乃是我见过的最愚蠢的行为。</p><p>所谓《原理》，即是需要掌握它为什么这样做，学习why，而不是how（怎样做）。极端认真的学生背下以太网的网线最大长度，数据帧的长度，每个字段的意义，IP报头的格式等等，但是忘了路由的原则，忘了TCP&#x2F;IP协议设计的宗旨。总之许多人花了大量的时间把书背得滚瓜烂熟却等于什么也没学。</p><p>在学习编程的时候这些学生也是这样，他们确切的记得C++语法的各个细节，看完了C++教程后看《Thinking in C++》、《Inside C++》、《C++ reference》、this C++、that C++……，然后是网上各种各样的关于C++语法的奇闻逸事，然后发现自己又忘了C++的一些语法，最后回头继续恶补…。</p><p>有个师弟就跟我说：“C++太难了，学了这里忘了那里，学了继承忘了模板。”我回答道：“你不去学就容易了”。我并没有教坏他，只是告诉他，死抠C++的语法就和孔已己炫耀茴香豆的茴字有几种写法一样毫无意义。你根本不需要对的C++语法太关心，动手编程就是了，有不记得的地方一查MSDN就立马搞定（具体可查看马海祥博客的《关于C语言、C++、Java和Python这4种程序开发语言的评价》相关介绍）。</p><p>马海祥得出这样一个结论：实际的开发过程中对程序语法的了解是最微不足道的知识，这是为什么我在为同学用Basic（我以前从没有学过它）写一个小程序的时候，只花了半个小时看了看语法，然后再用半个小时完成了程序，而一个小时后我又完全忘记了Basic的所有关键字。</p><p>3、不要盲目追赶时髦技术，忽略了基础知识</p><p>大多数的人都希望自己的东西能够马上跑起来，变成钱。这种想法对一个已经进入职业领域的程序员或者项目经理来说是合理的，而且IT技术进步是如此的快，不跟进就是失业。但是对于初学者来说（尤其是时间充裕的在校生），这种想法是另人费解的。</p><p>一个并未进入到行业竞争中来的初学者最大的资本便是他有足够的时间沉下心来学习基础性的东西，学习why而不是how。时髦的技术往往容易掌握，而且越来越容易掌握，这是商业利益的驱使，为了最大化的降低软件开发的成本。</p><p>但在IT领域内的现实就是这样，越容易掌握的东西，学习的人越多，而且淘汰得越快。每一次新的技术出来，都有许多初学者跟进，这些初学者由于缺乏必要的基础而使得自己在跟进的过程中花费大量的时间，而等他学会了，这种技术也快淘汰了。</p><p>基础的课程，比方数据结构，操作系统原理等等虽然不能让你立马就实现一个Linux（这是许多人嘲笑理论课程无用的原因），但它们能够显著的减少你在学习新技术时学习曲线的坡度，而且对于许多关键的技术（比Win32 SDK程序的设计，DDK的编程）来说甚至是不可或缺的。</p><p>一个活生生的例子是我和我的一个同学，在大一时我还找不到开机按纽，他已经会写些简单的汇编程序了。我把大二的所有时间花在了汇编，计算机体系结构，数据结构，操作系统原理等等这些课程的学习上，而他则开始学习PHP和VB，并追赶ASP的潮流（具体可查看马海祥博客的《PHP、JSP和ASP.NET全面对比，那种编程语言更好》相关介绍）。大三的时候我开始学习Windows操作系统原理，学习SDK编程，时间是漫长的，这时我才能够用VC开发出象模象样的应用程序。</p><p>我曾一度因为同学的程序已经能够运行而自己还在学习如何创建对话框而懊恼不已，但临到毕业才发现自己的选择是何等的正确，和我谈判的公司开出的薪水是他的两倍还多。</p><p>下面有一个不很恰当的比方：假设学习VB编程需要4个月，学习基础课程和VC的程序设计需要1年。那么如果你先学VB，再来学习后者，时间不会减少，还是1年，而反过来，如果先学习后者，再来学VB，也许你只需要1个星期就能学得非常熟练。</p><p>4、几个重要的基础课程</p><p>如果你是学生，或者如果你有充足的时间。我建议你仔细的掌握下面的知识。我的建议是针对那些希望在IT技术上有所成就的初学者。同时，我还列出了一些书目，这些书应该都还可以在书店买到。说实在的，我在读其他人的文章时最大的心愿就是希望作者列出一个书单。</p><p>（1）、大学英语</p><p>不要觉得好笑。我极力推荐这门课程是因为没有专业文档的阅读能力是不可想象的，中文的翻译往往在猴年马月才会出来，而现在的许多出版社干脆就直接把英文印刷上去，学习的方法是强迫自己看原版的教材，开始会看不懂，用多了自然熟练，吃得苦下得狠心绝对是任何行业都需要的品质。</p><p>（2）、计算机体系结构和汇编语言</p><p>关于体系结构的书遍地都是，而且也大同小异，倒是汇编有一本非常好的书《80x86汇编语言程序设计教程》（清华大学出版社，黑色封面，杨季文著），你需要着重学习386后保护模式的程序设计。否则你在学习现代操作系统底层的一些东西的时候会觉得是在看天书。</p><p>（3）、计算机操作系统原理</p><p>我们的开发总是在特定的操作系统上进行，如果不是，只有一种可能：你在自己实现一个操作系统，无论如何，操作系统原理是必读的。这就象我们为一个芯片制作外围设备时，芯片基本的工作时序是必需了解的。这一类书也很多，我没有发现哪一本书非常出众，只是觉得在看完了这些书后如果有空就应该看看《Inside Windows 2000》(微软出版社，我看的是英文版的，中文的书名想必是Windows 2000技术内幕之类吧)。</p><p>（4）、数据结构和算法</p><p>这门课程能够决定一个人程序设计水平的高低，是一门核心课程。我首选的是清华版的。很多人喜欢买C++版的，但我觉得没有必要，C++的语法让算法实现过程变得复杂多了，而且许多老师喜欢用模块这一东西让算法变得更复杂，倒是在学完了C版的书以后再来浏览一下C++的版的书是最好的。</p><p>（5）、软件工程</p><p>这门课程是越到后来就越发现它的重要，虽然刚开始看时就象看马哲一样不知所云。马海祥的建议是看《实用软件工程》（黄色，清华）。不要花太多的时间去记条条框框，看不懂就跳过去。在每次自己完成了一个软件设计任务（不管是练习还是工作）以后再来回顾回顾，每次都会有收获。</p><p>（6）、Windows 程序设计</p><p>我建议任何企图设计Windows程序的人在学习VC以前仔细的学完它，而且前面的那本《Inside Windows 2000》也最好放到这本书的后面读。在这本书中，没有C++，没有GUI，没有控件，有的就是如何用原始的C语言来完成Windows程序设计。</p><p>在学完了它以后，你才会发现VC其实是很容易学的，千万不要在没有看完这本书以前提前学习VC，你最好碰都不要碰，我知道的许多名校甚至都已经用它作为教材进行授课。可见其重要。</p><p>5、对于其它的课程的选择方法</p><p>对于其它的课程有这样简单的选择方法：如果你是计算机系的，请学好你所有的专业基础课；如果不是，请参照计算机系的课程表。如果你发现自己看一本书时无法看下去了，请翻到书的最后，看看它的参考文献，找到它们并学习它们，再回头看这本书。</p><p>如果一本书的书名中带有“原理”两个字，你一定不要去记忆它其中的细节，你应该以一天至少50页的速度掌握其要领；尽可能多的在计算机上实践一种理论或者算法。</p><p>6、把最多的时间花在学习上</p><p>这是对初学者最后的忠告，把每个星期玩CS或者CS的时间压缩到最少，不玩它们是最好的。同时，如果你的ASP技术已经能够来钱，甚至有公司请你兼职的话，这就证明你的天分能够保证你在努力的学习之后取得更好的收益，你应该去做更复杂的东西，眼光放长远一些，这无论是对谁都是适用的。</p><p>马海祥博客点评：</p><p>每天读的书太多，容易让人迷失方向。一定要在每天晚上想想自己学了些什么，还有些什么相关的东西需要掌握，自己对什么最感兴趣，在一本书上花的时间太长还是不够！也应该多想想未来最有可能出现的应用，这样能够让你不是追赶技术潮流而是引领技术潮流。</p><p>同时，努力使用现在已经掌握的技术和理论去制作具有一定新意的东西，坚持这样做能够让你真正成为一个软件“研发者”而不仅仅是一个coder！</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>焦虑的旋涡</title>
      <link href="/2020/11/19/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02020%E5%B9%B411%E6%9C%8819%E6%97%A5/"/>
      <url>/2020/11/19/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02020%E5%B9%B411%E6%9C%8819%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="焦虑的旋涡"><a href="#焦虑的旋涡" class="headerlink" title="焦虑的旋涡"></a>焦虑的旋涡</h1><p>已经焦虑好长一段时间了，陷入了一个很负能量的思维漩涡。</p><p>大事小事，各种事情都会产生焦虑，很不应该这样。</p><p>卖掉二手笔记本电脑，全程非常顺利，买家话少，事少，我却很担心中间会有什么其他纠纷问题，甚至担心有套路，很不应该这样啊。</p><p>今早坐地铁上班，旁边一个中年男子在用kindle看纯英文的书籍，一个我曾经想冲动消费的电子设备，一个我一直以来最羡慕的语言技能，他拥有这些，却依然通着勤上班。我不喜欢。</p><p>我是不喜欢上班么？还是不喜欢把太多精力放在工作上？</p><p>我想不清楚我到底向往什么样的生活，目光所及范围内，下一阶段的岗位并不感兴趣。</p><p>现阶段的焦虑，到底是因为压力，还是因为没有压力？</p>]]></content>
      
      
      <categories>
          
          <category> 心情随记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用记录——Canal</title>
      <link href="/2020/09/09/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Canal/"/>
      <url>/2020/09/09/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Canal/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Canal"><a href="#初识Canal" class="headerlink" title="初识Canal"></a>初识Canal</h1><p><strong>1、应用场景</strong></p><p>在前面的统计分析功能中，我们采取了服务调用获取统计数据，这样耦合度高，效率相对较低，目前我采取另一种实现方式，通过实时同步数据库表的方式实现，例如我们要统计每天注册与登录人数，我们只需把会员表同步到统计库中，实现本地统计就可以了，这样效率更高，耦合度更低，Canal就是一个很好的数据库同步工具。canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。</p><p><strong>2、Canal环境搭建</strong></p><p>（这里的MySQL和Canal都是使用docker容器，相应的配置文件也使用了宿主机映射路径）</p><p><strong>canal的原理是基于mysql binlog技术，所以这里一定需要开启mysql的binlog写入功能</strong></p><p><strong>开启mysql服务：</strong>  service mysql start  <strong>（或者 systemctl start mysqld.service）</strong></p><p><strong>（1）检查binlog功能是否有开启</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mysql&gt; show variables like &#x27;log_bin&#x27;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| log_bin       | OFF    |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>（2）如果显示状态为OFF表示该功能未开启，开启binlog功能</strong></p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs cnf">[mysqld]<br>## 设置server_id，同一局域网中需要唯一<br>server_id=101<br>## 指定不需要同步的数据库名称<br>binlog-ignore-db=mysql <br>## 开启二进制日志功能<br>log-bin=mall-mysql-bin <br>## 设置二进制日志使用内存大小（事务）<br>binlog_cache_size=1M <br>## 设置使用的二进制日志格式（mixed,statement,row）<br>binlog_format=row <br>## 二进制日志过期清理时间。默认值为0，表示不自动清理。<br>expire_logs_days=7 <br>## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。<br>## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致<br>slave_skip_errors=1062<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">1，修改 mysql 的配置文件 my.cnf<br>vi /etc/my.cnf <br>追加内容：<br>log-bin=mysql-bin     #binlog文件名<br>binlog_format=ROW     #选择row模式<br>server_id=1           #mysql实例id,不能和canal的slaveId重复<br>2，重启 mysql：<br>service mysql restart   <br>3，登录 mysql 客户端，查看 log_bin 变量<br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&#x27;log_bin&#x27;</span>;</span><br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| log_bin       | ON|<br>+---------------+-------+<br>1 row in set (0.00 sec)<br>————————————————<br>如果显示状态为ON表示该功能已开启<br></code></pre></td></tr></table></figure><p><strong>（3）在mysql里面添加以下的相关用户和权限</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">CREATE USER &#x27;canal&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;canal&#x27;;<br>GRANT SHOW VIEW, SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h1 id="下载安装Canal服务"><a href="#下载安装Canal服务" class="headerlink" title="下载安装Canal服务"></a>下载安装Canal服务</h1><p>（1）运行canal容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">带配置映射</span><br>docker run -p 11111:11111 --name canal -v  /mydata/canal/example/instance.properties:/home/admin/canal-server/conf/example/instance.properties  -d canal/canal-server<br></code></pre></td></tr></table></figure><p>(如果映射文件报错unknown: Are you trying to mount a directory onto a file (or vice-versa)?，就删除自动创建的目录，新建一个文件，从新运行容器)</p><p>（2）修改配置文件</p><p>（这里如果映射到的配置文件和容器内的配置文件都是空的，可以<a href="https://github.com/alibaba/canal/releases">下载</a>一个canal复制instance.properties里的内容进行修改。）</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vi /mydata/canal/example/instance.properties<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#需要改成自己的数据库信息</span><br><span class="hljs-attr">canal.instance.master.address</span>=<span class="hljs-string">172.16.0.8:3306</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#需要改成自己的数据库用户名与密码</span><br><br><span class="hljs-attr">canal.instance.dbUsername</span>=<span class="hljs-string">canal</span><br><span class="hljs-attr">canal.instance.dbPassword</span>=<span class="hljs-string">canal</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#需要改成同步的数据库表规则，例如只是同步一下表</span><br><span class="hljs-comment">#canal.instance.filter.regex=.*\\..*</span><br><span class="hljs-attr">canal.instance.filter.regex</span>=<span class="hljs-string">wx_keywords</span><br></code></pre></td></tr></table></figure><p>重启 canal。</p><h1 id="Spring-Boot中使用Canal"><a href="#Spring-Boot中使用Canal" class="headerlink" title="Spring Boot中使用Canal"></a>Spring Boot中使用Canal</h1><p>1，引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--mysql--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbutils<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbutils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.otter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>canal.client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2，修改配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 服务端口</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">10000</span><br><span class="hljs-comment"># 服务名</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">canal-client</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 环境设置：dev、test、prod</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">dev</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># mysql数据库连接(这里连接的是本地数据库，也就是同步后写入的数据库)</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/edu?serverTimezone=GMT%2B8</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p>3，编写canal客户端类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.*;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.Message;<br><span class="hljs-keyword">import</span> com.google.protobuf.InvalidProtocolBufferException;<br><span class="hljs-keyword">import</span> org.apache.commons.dbutils.DbUtils;<br><span class="hljs-keyword">import</span> org.apache.commons.dbutils.QueryRunner;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanalClient</span> &#123;<br><br>    <span class="hljs-comment">//sql队列</span><br>    <span class="hljs-keyword">private</span> Queue&lt;String&gt; SQL_QUEUE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * canal入库方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">CanalConnector</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> CanalConnectors.newSingleConnector(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;192.168.0.58&quot;</span>,<br>                <span class="hljs-number">11111</span>), <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;canal&quot;</span>, <span class="hljs-string">&quot;canal&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connector.connect();<br>            connector.subscribe(<span class="hljs-string">&quot;.*\\..*&quot;</span>);<br>            connector.rollback();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//尝试从master那边拉去数据batchSize条记录，有多少取多少</span><br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> connector.getWithoutAck(batchSize);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">batchId</span> <span class="hljs-operator">=</span> message.getId();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> message.getEntries().size();<br>                    <span class="hljs-keyword">if</span> (batchId == -<span class="hljs-number">1</span> || size == <span class="hljs-number">0</span>) &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dataHandle(message.getEntries());<br>                    &#125;<br>                    connector.ack(batchId);<br><br>                    <span class="hljs-comment">//当队列里面堆积的sql大于一定数值的时候就模拟执行</span><br>                    <span class="hljs-keyword">if</span> (SQL_QUEUE.size() &gt;= <span class="hljs-number">1</span>) &#123;<br>                        executeQueueSql();<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            connector.disconnect();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟执行队列里面的sql语句</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeQueueSql</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> SQL_QUEUE.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> SQL_QUEUE.poll();<br>            System.out.println(<span class="hljs-string">&quot;[sql]----&gt; &quot;</span> + sql);<br><br>            <span class="hljs-built_in">this</span>.execute(sql.toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entrys</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dataHandle</span><span class="hljs-params">(List&lt;Entry&gt; entrys)</span> <span class="hljs-keyword">throws</span> InvalidProtocolBufferException &#123;<br>        <span class="hljs-keyword">for</span> (Entry entry : entrys) &#123;<br>            <span class="hljs-keyword">if</span> (EntryType.ROWDATA == entry.getEntryType()) &#123;<br>                <span class="hljs-type">RowChange</span> <span class="hljs-variable">rowChange</span> <span class="hljs-operator">=</span> RowChange.parseFrom(entry.getStoreValue());<br>                <span class="hljs-type">EventType</span> <span class="hljs-variable">eventType</span> <span class="hljs-operator">=</span> rowChange.getEventType();<br>                <span class="hljs-keyword">if</span> (eventType == EventType.DELETE) &#123;<br>                    saveDeleteSql(entry);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType == EventType.UPDATE) &#123;<br>                    saveUpdateSql(entry);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType == EventType.INSERT) &#123;<br>                    saveInsertSql(entry);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存更新语句</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUpdateSql</span><span class="hljs-params">(Entry entry)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">RowChange</span> <span class="hljs-variable">rowChange</span> <span class="hljs-operator">=</span> RowChange.parseFrom(entry.getStoreValue());<br>            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();<br>            <span class="hljs-keyword">for</span> (RowData rowData : rowDatasList) &#123;<br>                List&lt;Column&gt; newColumnList = rowData.getAfterColumnsList();<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;update &quot;</span> + entry.getHeader().getTableName() + <span class="hljs-string">&quot; set &quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newColumnList.size(); i++) &#123;<br>                    sql.append(<span class="hljs-string">&quot; &quot;</span> + newColumnList.get(i).getName()<br>                            + <span class="hljs-string">&quot; = &#x27;&quot;</span> + newColumnList.get(i).getValue() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    <span class="hljs-keyword">if</span> (i != newColumnList.size() - <span class="hljs-number">1</span>) &#123;<br>                        sql.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                    &#125;<br>                &#125;<br>                sql.append(<span class="hljs-string">&quot; where &quot;</span>);<br>                List&lt;Column&gt; oldColumnList = rowData.getBeforeColumnsList();<br>                <span class="hljs-keyword">for</span> (Column column : oldColumnList) &#123;<br>                    <span class="hljs-keyword">if</span> (column.getIsKey()) &#123;<br>                        <span class="hljs-comment">//暂时只支持单一主键</span><br>                        sql.append(column.getName() + <span class="hljs-string">&quot;=&quot;</span> + column.getValue());<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                SQL_QUEUE.add(sql.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存删除语句</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveDeleteSql</span><span class="hljs-params">(Entry entry)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">RowChange</span> <span class="hljs-variable">rowChange</span> <span class="hljs-operator">=</span> RowChange.parseFrom(entry.getStoreValue());<br>            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();<br>            <span class="hljs-keyword">for</span> (RowData rowData : rowDatasList) &#123;<br>                List&lt;Column&gt; columnList = rowData.getBeforeColumnsList();<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;delete from &quot;</span> + entry.getHeader().getTableName() + <span class="hljs-string">&quot; where &quot;</span>);<br>                <span class="hljs-keyword">for</span> (Column column : columnList) &#123;<br>                    <span class="hljs-keyword">if</span> (column.getIsKey()) &#123;<br>                        <span class="hljs-comment">//暂时只支持单一主键</span><br>                        sql.append(column.getName() + <span class="hljs-string">&quot;=&quot;</span> + column.getValue());<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                SQL_QUEUE.add(sql.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存插入语句</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> entry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveInsertSql</span><span class="hljs-params">(Entry entry)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">RowChange</span> <span class="hljs-variable">rowChange</span> <span class="hljs-operator">=</span> RowChange.parseFrom(entry.getStoreValue());<br>            List&lt;RowData&gt; rowDatasList = rowChange.getRowDatasList();<br>            <span class="hljs-keyword">for</span> (RowData rowData : rowDatasList) &#123;<br>                List&lt;Column&gt; columnList = rowData.getAfterColumnsList();<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;insert into &quot;</span> + entry.getHeader().getTableName() + <span class="hljs-string">&quot; (&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; columnList.size(); i++) &#123;<br>                    sql.append(columnList.get(i).getName());<br>                    <span class="hljs-keyword">if</span> (i != columnList.size() - <span class="hljs-number">1</span>) &#123;<br>                        sql.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                    &#125;<br>                &#125;<br>                sql.append(<span class="hljs-string">&quot;) VALUES (&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; columnList.size(); i++) &#123;<br>                    <span class="hljs-keyword">if</span> (columnList.get(i).getValue().isEmpty())&#123;<br>                        <span class="hljs-comment">//mysql 5.x以上 空值 要传 NULL 不能传空字符串</span><br>                        sql.append(<span class="hljs-string">&quot;NULL&quot;</span>);<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        sql.append(<span class="hljs-string">&quot;&#x27;&quot;</span> + columnList.get(i).getValue() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (i != columnList.size() - <span class="hljs-number">1</span>) &#123;<br>                        sql.append(<span class="hljs-string">&quot;,&quot;</span>);<br>                    &#125;<br>                &#125;<br>                sql.append(<span class="hljs-string">&quot;)&quot;</span>);<br>                SQL_QUEUE.add(sql.toString());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 入库</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sql</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String sql)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> == sql) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            con = dataSource.getConnection();<br>            <span class="hljs-type">QueryRunner</span> <span class="hljs-variable">qr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> qr.execute(con, sql);<br>            System.out.println(<span class="hljs-string">&quot;update: &quot;</span>+ row);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            DbUtils.closeQuietly(con);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4，编写canal服务启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanalApplication</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> CanalClient canalClient;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CanalApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... strings)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//项目启动，执行canal客户端监听</span><br>        canalClient.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_Nginx</title>
      <link href="/2020/09/09/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Nginx/"/>
      <url>/2020/09/09/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><p>（网上大多数教程都是按照官方下载包，编译源码方式安装，这里记录yum安装方式和docker中使用）</p><p>一、Linux直接安装nginx（yum方式）</p><p>1、添加源</p><p>默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm<br>2、安装Nginx<br></code></pre></td></tr></table></figure><p>2、通过yum search nginx看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum install -y nginx<br></code></pre></td></tr></table></figure><p>3、启动Nginx并设置开机自动运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systemctl start nginx.service<br>systemctl enable nginx.service<br></code></pre></td></tr></table></figure><p>4、查看Nginx 版本和主要路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@duogeECS ~]# nginx -v<br>nginx version: nginx/1.18.0<br><br><br>[root@duogeECS ~]# rpm -ql nginx<br>/etc/logrotate.d/nginx<br>/etc/nginx<br>/etc/nginx/conf.d<br>/etc/nginx/conf.d/default.conf<br>/etc/nginx/fastcgi_params<br>/etc/nginx/koi-utf<br>/etc/nginx/koi-win<br>/etc/nginx/mime.types<br>/etc/nginx/modules<br>/etc/nginx/nginx.conf<br>/etc/nginx/scgi_params<br>/etc/nginx/uwsgi_params<br>/etc/nginx/win-utf<br>/etc/sysconfig/nginx<br>/etc/sysconfig/nginx-debug<br>/usr/lib/systemd/system/nginx-debug.service<br>/usr/lib/systemd/system/nginx.service<br>/usr/lib64/nginx<br>/usr/lib64/nginx/modules<br>/usr/libexec/initscripts/legacy-actions/nginx<br>/usr/libexec/initscripts/legacy-actions/nginx/check-reload<br>/usr/libexec/initscripts/legacy-actions/nginx/upgrade<br>/usr/sbin/nginx<br>/usr/sbin/nginx-debug<br>/usr/share/doc/nginx-1.18.0<br>/usr/share/doc/nginx-1.18.0/COPYRIGHT<br>/usr/share/man/man8/nginx.8.gz<br>/usr/share/nginx<br>/usr/share/nginx/html<br>/usr/share/nginx/html/50x.html<br>/usr/share/nginx/html/index.html<br>/var/cache/nginx<br>/var/log/nginx<br></code></pre></td></tr></table></figure><p>5、配置文件相关</p><p>以下是Nginx的默认路径：</p><p>Nginx配置路径：&#x2F;etc&#x2F;nginx&#x2F;<br>PID目录：&#x2F;var&#x2F;run&#x2F;nginx.pid<br>错误日志：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log<br>访问日志：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log<br>默认站点目录：&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>将新增的 *.conf 文件 放置到 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;文件夹下, 然后nginx -s reload即可生效。</p><p>测试Nginx配置是否正确：<br>nginx -t</p><p>二、Docker中安装nginx</p><p>1、下载Nginx1.18的docker镜像,并运行容器:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker pull nginx:1.18<br><br>docker run -p 80:80 --name nginx \<br>-v /mydata/nginx/html:/usr/share/nginx/html \<br>-v /mydata/nginx/logs:/var/log/nginx  \<br>-d nginx:1.18<br></code></pre></td></tr></table></figure><p>2、将容器内的配置文件拷贝到指定目录:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker container cp nginx:/etc/nginx /mydata/nginx/<br></code></pre></td></tr></table></figure><p>3、修改文件名称:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mv nginx conf<br></code></pre></td></tr></table></figure><p>4、停止并删除容器</p><p>5、重新建立Nginx容器并启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p 80:80 --name nginx \<br>-v /mydata/nginx/html:/usr/share/nginx/html \<br>-v /mydata/nginx/logs:/var/log/nginx  \<br>-v /mydata/nginx/conf:/etc/nginx \<br>-d nginx:1.18<br></code></pre></td></tr></table></figure><h2 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h2><p>(目前是基本配置，待完善详细说明和更多用法的配置文件)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">server &#123;<br>    listen       80;<br>    server_name  www.duo.com; #修改域名<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br><br>server &#123;<br>    listen       80;<br>    server_name  file.duo.com; #修改域名<br><br>    location / &#123;<br>        root   /usr/share/nginx/html/file; #代理到file文件夹中<br>    &#125;<br><br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br><br>server &#123;<br>    listen       80;<br>    server_name  www.8.yuhouedu.com; #修改域名<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br><br>location ~ /wx/ &#123;           <br>proxy_pass http://14.17.114.243:8003;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被讨厌的勇气</title>
      <link href="/2020/07/15/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02020%E5%B9%B47%E6%9C%8815%E6%97%A5/"/>
      <url>/2020/07/15/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02020%E5%B9%B47%E6%9C%8815%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="被讨厌的勇气"><a href="#被讨厌的勇气" class="headerlink" title="被讨厌的勇气"></a>被讨厌的勇气</h1><p>刚刚听了一章《被讨厌的勇气》的解读，内容包含了目的论和</p><p>改变的勇气。</p><p>结合自己前一段时间的心态，确实认同这种观点。</p><p>大概从上周开始，打算每天开始健身，练字。前几天执行还可以，后面几天就逐渐没有每天执行了，而且到了晚上还会在心里给自己找一个理由。例如身体不舒服，吃饭太晚了不宜运动等。</p><p>其实这都是已经确定不去执行目标才有的。</p><p>所以目的论还是很对的，起码能在当前提高一些执行力。</p>]]></content>
      
      
      <categories>
          
          <category> 心情随记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>喜欢的诗歌《我从未见过懒惰的人》</title>
      <link href="/2020/03/05/%E6%94%B6%E8%97%8F%E6%91%98%E5%BD%95/%E6%88%91%E4%BB%8E%E6%9C%AA%E8%A7%81%E8%BF%87%E6%87%92%E6%83%B0%E7%9A%84%E4%BA%BA/"/>
      <url>/2020/03/05/%E6%94%B6%E8%97%8F%E6%91%98%E5%BD%95/%E6%88%91%E4%BB%8E%E6%9C%AA%E8%A7%81%E8%BF%87%E6%87%92%E6%83%B0%E7%9A%84%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="我从未见过懒惰的人"><a href="#我从未见过懒惰的人" class="headerlink" title="我从未见过懒惰的人"></a>我从未见过懒惰的人</h1><p>我从未见过懒惰的人；</p><p>我见过</p><p>有个人有时在下午睡觉，</p><p>在雨天不出门，</p><p>但他不是个懒惰的人。</p><p>请在我胡言乱语之前，</p><p>想一想，他是个懒惰的人，还是</p><p>他的行为被我们称为“懒惰”？</p><p>我从未见过愚蠢的孩子；</p><p>我见过有个孩子有时做的事</p><p>我不理解</p><p>或不按我的吩咐做事情；</p><p>但他不是愚蠢的孩子。</p><p>请在你说他愚蠢之前，</p><p>想一想，他是个愚蠢的孩子，还是，</p><p>他懂的事情与你不一样？</p><p>我使劲看了又看</p><p>但从未看到厨师；</p><p>我看到有个人把食物</p><p>调配在一起，</p><p>打起了火，</p><p>看着炒菜的炉子——</p><p>我看到这些但没有看到厨师。</p><p>告诉我，当你看的时候，</p><p>你看到的是厨师，还是有个人</p><p>做的事情被我们称为烹饪？</p><p>我们说有的人懒惰</p><p>另一些人说他们与世无争，</p><p>我们说有的人愚蠢</p><p>另一些人说他学习方法有区别。</p><p>因此，我得出结论，</p><p>如果不把事实</p><p>和意见混为一谈，</p><p>我们将不再困惑。</p><p>因为你可能无所谓，我也想说：</p><p>这只是我的意见。</p><p>——鲁思·贝本梅尔</p>]]></content>
      
      
      <categories>
          
          <category> 收藏摘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_MongoDB</title>
      <link href="/2020/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/MongoDB/"/>
      <url>/2020/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/MongoDB/</url>
      
        <content type="html"><![CDATA[<h1 id="初识MongoDB"><a href="#初识MongoDB" class="headerlink" title="初识MongoDB"></a>初识MongoDB</h1><blockquote><p>Mongodb是为快速开发互联网Web应用而构建的数据库系统，其数据模型和持久化策略就是为了构建高读&#x2F;写吞吐量和高自动灾备伸缩性的系统。</p></blockquote><h3 id="1，下载并安装MongoDB"><a href="#1，下载并安装MongoDB" class="headerlink" title="1，下载并安装MongoDB"></a>1，下载并安装MongoDB</h3><h4 id="windows安装："><a href="#windows安装：" class="headerlink" title="windows安装："></a>windows安装：</h4><p>2，在安装路径下创建data\db和data\log两个文件夹</p><p>3，在安装路径下创建mongod.cfg配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systemLog:<br> destination: file<br> path: 安装路径\data\log\mongod.log<br>storage:<br> dbPath: 安装路径\data\db<br></code></pre></td></tr></table></figure><p>4，安装为服务（运行命令需要用管理员权限）</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">D:\developer\env\MongoDB\bin\mongod.exe --config &quot;D:\developer\env\MongoDB\mongod.cfg&quot; --install<br></code></pre></td></tr></table></figure><p>5，服务相关命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">启动服务：net start MongoDB<br>关闭服务：net stop MongoDB<br>移除服务：D:\developer\env\MongoDB\bin\mongod.exe --remove<br></code></pre></td></tr></table></figure><h4 id="Linux—docker安装："><a href="#Linux—docker安装：" class="headerlink" title="Linux—docker安装："></a>Linux—docker安装：</h4><p>1，下载mongo镜像</p><p>2，安装，并配置data&#x2F;db的映射路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -p 27017:27017 --name mongo \<br>-v /mydata/mongo/db:/data/db \<br>-d mongo:3.2<br></code></pre></td></tr></table></figure><blockquote><p>可视化工具可使用Navicat</p></blockquote><h1 id="Spring-Data-Mongodb"><a href="#Spring-Data-Mongodb" class="headerlink" title="Spring Data Mongodb"></a>Spring Data Mongodb</h1><blockquote><p>和Spring Data Elasticsearch类似，Spring Data Mongodb是Spring提供的一种以Spring Data风格来操作数据存储的方式，它可以避免编写大量的样板代码。</p></blockquote><h3 id="1，添加依赖"><a href="#1，添加依赖" class="headerlink" title="1，添加依赖"></a>1，添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!---mongodb相关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2，配置连接参数"><a href="#2，配置连接参数" class="headerlink" title="2，配置连接参数"></a>2，配置连接参数</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br> <span class="hljs-attr">data:</span><br>  <span class="hljs-attr">mongodb:</span><br>   <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># mongodb的连接地址</span><br>   <span class="hljs-attr">port:</span> <span class="hljs-number">27017</span> <span class="hljs-comment"># mongodb的连接端口号</span><br>   <span class="hljs-attr">database:</span> <span class="hljs-string">db_name</span> <span class="hljs-comment"># mongodb的连接的数据库</span><br></code></pre></td></tr></table></figure><h3 id="3，定义实体类"><a href="#3，定义实体类" class="headerlink" title="3，定义实体类"></a>3，定义实体类</h3><p>文档对象的ID域添加@Id注解，需要检索的字段添加@Indexed注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Document</span><span class="hljs-comment">//mongodb</span><br><span class="hljs-meta">@Data</span><span class="hljs-comment">//lombok</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IpSave</span> &#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String id;<span class="hljs-comment">//id为String 类型。</span><br>    <span class="hljs-meta">@Indexed</span><br>    <span class="hljs-keyword">private</span> String ip;<br>    <span class="hljs-keyword">private</span> LocalDateTime time;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常用注解（用在实体类上，映射到数据库）"><a href="#常用注解（用在实体类上，映射到数据库）" class="headerlink" title="常用注解（用在实体类上，映射到数据库）"></a>常用注解（用在实体类上，映射到数据库）</h4><ul><li>@Document:标示映射到Mongodb文档上的领域对象</li><li>@Id:标示某个域为ID域</li><li>@Indexed:标示某个字段为Mongodb的索引字段</li></ul><h3 id="4，自定义MongoRepository接口"><a href="#4，自定义MongoRepository接口" class="headerlink" title="4，自定义MongoRepository接口"></a>4，自定义MongoRepository接口</h3><p>继承MongoRepository接口，这样就拥有了一些基本的Mongodb数据操作方法，同时定义了一个衍生查询方法。</p><h4 id="Spring-Data方式操作数据"><a href="#Spring-Data方式操作数据" class="headerlink" title="Spring Data方式操作数据"></a>Spring Data方式操作数据</h4><p>继承MongoRepository接口可以获得常用的数据操作方法</p><p>衍生查询：在接口中直接指定查询方法名称便可查询，无需进行实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IpSaveMongoRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MongoRepository</span>&lt;IpSave,String&gt; &#123;<br><span class="hljs-comment">//这个方法的命名有要求，功能根据方法名来自动推测</span><br>    <span class="hljs-comment">//写的时候IDEA会提示对应字段和条件，</span><br>    <span class="hljs-comment">//命名方式关键字和sql类似</span><br>    List&lt;IpSave&gt; <span class="hljs-title function_">findByIpLikeOrderByTimeDesc</span><span class="hljs-params">(String ip)</span>;<br>    <br>    <span class="hljs-comment">//使用@Query注解可以用Mongodb的JSON查询语句进行查询</span><br>    <span class="hljs-comment">//?0标识匹配方法的第一个参数，?1第二个参数，&#123; &#x27;_id&#x27; : 1&#125;表示结果只返回_id这个属性，其他属性在对象中都是空的。</span><br><span class="hljs-meta">@Query(value = &quot;&#123;&#x27;ip&#x27;:?0&#125;&quot;, fields = &quot;&#123;&#x27;id&#x27;:1,&#x27;ip&#x27;:1&#125;&quot;)</span><br>    List&lt;IpSave&gt; <span class="hljs-title function_">findList</span><span class="hljs-params">(String ip)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来在自己写的Service实现类中，引入自定义的MongoRepository，即可使用对应方法。</p>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_RabbitMQ</title>
      <link href="/2020/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/RabbitMQ/"/>
      <url>/2020/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h1><blockquote><p>RabbitMQ是一个被广泛使用的开源消息队列。它是轻量级且易于部署的，它能支持多种消息协议。RabbitMQ可以部署在分布式和联合配置中，以满足高规模、高可用性的需求。</p></blockquote><p>Exchanges：交换器</p><p>​direct：单播模式</p><p>​fanout：群播模式</p><p>​topic：组播模式（#. 匹配多单词   *.匹配一单词）</p><p>Queues：消息队列</p><h2 id="下载安装RabbitMQ"><a href="#下载安装RabbitMQ" class="headerlink" title="下载安装RabbitMQ"></a>下载安装RabbitMQ</h2><p>windows:</p><p>1,安装Erlang</p><p>2,安装RabbitMQ</p><p>3,安装完成后，进入RabbitMQ安装目录下的sbin目录</p><p>4,启动命令行，然后输入以下命令启动管理功能：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><p>5,访问地址查看是否安装成功：<a href="http://localhost:15672/">http://localhost:15672/</a></p><p>输入账号密码并登录：guest guest</p><p>Linux-docker:</p><p>1,下载RabbitMQ镜像，并启动容器:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d --name rabbitmq \<br>--publish 5671:5671 --publish 5672:5672 --publish 4369:4369 \<br>--publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \<br>rabbitmq:3.7.15<br></code></pre></td></tr></table></figure><p>2,进入容器并开启管理功能</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker exec -it rabbitmq /bin/bash<br>rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><p>3,访问地址查看是否安装成功：<a href="http://192.168.3.101:15672/">http://192.168.3.101:15672/</a></p><p>​输入账号密码并登录：guest guest</p><h1 id="Spring-Boot中使用RabbitMQ"><a href="#Spring-Boot中使用RabbitMQ" class="headerlink" title="Spring Boot中使用RabbitMQ"></a>Spring Boot中使用RabbitMQ</h1><p>1，添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--消息队列相关依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2，配置连接</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span> <br>    <span class="hljs-attr">rabbitmq:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># rabbitmq的连接地址</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># rabbitmq的连接端口号</span><br>        <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span> <span class="hljs-comment"># rabbitmq的虚拟host</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span> <span class="hljs-comment"># rabbitmq的用户名</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span> <span class="hljs-comment"># rabbitmq的密码</span><br>        <span class="hljs-attr">publisher-confirms:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#如果对异步消息需要回调必须设置为true</span><br></code></pre></td></tr></table></figure><p>3，编写配置类，下面案例中配置了：消息序列化方式，延迟消息 和 实际消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableRabbit</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQConfig</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用Jackson序列化方式存储队列中的消息(默认是以JDK序列化方式)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息实际队列所绑定的交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    DirectExchange <span class="hljs-title function_">orderDirect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (DirectExchange) ExchangeBuilder<br>                .directExchange(QueueEnum.QUEUE_NEWS.getExchange())<br>                .durable(<span class="hljs-literal">true</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息延迟队列所绑定的交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    DirectExchange <span class="hljs-title function_">orderTtlDirect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (DirectExchange) ExchangeBuilder<br>                .directExchange(QueueEnum.QUEUE_TTL_NEWS.getExchange())<br>                .durable(<span class="hljs-literal">true</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实际消费队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">orderQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(QueueEnum.QUEUE_NEWS.getName());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息延迟队列（死信队列）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">orderTtlQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .durable(QueueEnum.QUEUE_TTL_NEWS.getName())<br>                .withArgument(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, QueueEnum.QUEUE_NEWS.getExchange())<span class="hljs-comment">//到期后转发的交换机</span><br>                .withArgument(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, QueueEnum.QUEUE_NEWS.getRouteKey())<span class="hljs-comment">//到期后转发的路由键</span><br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将消息队列绑定到交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    Binding <span class="hljs-title function_">orderBinding</span><span class="hljs-params">(DirectExchange orderDirect,Queue orderQueue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(orderQueue)<br>                .to(orderDirect)<br>                .with(QueueEnum.QUEUE_NEWS.getRouteKey());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将消息延迟队列绑定到交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    Binding <span class="hljs-title function_">orderTtlBinding</span><span class="hljs-params">(DirectExchange orderTtlDirect,Queue orderTtlQueue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(orderTtlQueue)<br>                .to(orderTtlDirect)<br>                .with(QueueEnum.QUEUE_TTL_NEWS.getRouteKey());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3，编写发送消息的类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMqSender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RabbitMqSender.class);<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(Long id,<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> delayTimes)</span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;send delay message :&#123;&#125;&quot;</span>,id);<br>        <span class="hljs-comment">//给延迟队列发送消息</span><br>        amqpTemplate.convertAndSend(QueueEnum.QUEUE_TTL_NEWS.getExchange(), QueueEnum.QUEUE_TTL_NEWS.getRouteKey(), id, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessagePostProcessor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException &#123;<br>                <span class="hljs-comment">//给消息设置延迟毫秒值</span><br>                message.getMessageProperties().setExpiration(String.valueOf(delayTimes));<br>                <span class="hljs-keyword">return</span> message;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4，编写消息接收监听</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queues = &quot;kj.news&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMqReceiver</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RabbitMqReceiver.class);<br><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Long id)</span> &#123;<br>        LOGGER.info(<span class="hljs-string">&quot;receive delay message orderId:&#123;&#125;&quot;</span>,id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5，调用发送消息</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   RabbitMqSender rabbitMqSender;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMq</span><span class="hljs-params">()</span>&#123;<br>       rabbitMqSender.sendMessage(<span class="hljs-number">1L</span>,<span class="hljs-number">3000</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
            <tag> Java </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_Redis</title>
      <link href="/2020/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Redis/"/>
      <url>/2020/01/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><blockquote><p>Redis是用C语言开发的一个高性能键值对数据库，可用于数据缓存，主要用于处理大量数据的高访问负载。</p></blockquote><p>1，下载并安装Redis</p><p>​windows安装：</p><p>​在当前地址栏输入cmd后，执行redis的启动命令：redis-server.exe redis.windows.conf</p><p>​Linux—docker安装：</p><p>​</p><p>2，</p><h1 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h1><blockquote><p>官网可以查看所有命令的说明和使用</p></blockquote><p>select 0&#x2F;&#x2F;切换到0号数据库（默认配置16个数据库，0~15）</p><p>keys *&#x2F;&#x2F;查看所有的key</p><p>set ‘key’ ‘value’&#x2F;&#x2F;插入或更新一条数据</p><p>get ‘key’&#x2F;&#x2F;获取该key的value</p><p>del ‘key’&#x2F;&#x2F;删除数据</p><p>flushdb&#x2F;&#x2F;清除该数据库数据</p><p>flushall&#x2F;&#x2F;清除全部数据</p><p>exists ‘key’&#x2F;&#x2F;判断这条数据是否存在</p><p>move ‘key’ ‘目标数据库编号’&#x2F;&#x2F;移动数据</p><p>expire ‘key’ ‘有效时间’&#x2F;&#x2F;设置该条数据的有效时间</p><p>ttl ‘key’&#x2F;&#x2F;查看该条数据的有效时间</p><p>type ‘key’&#x2F;&#x2F;查看数据类型</p><h2 id="String-类型："><a href="#String-类型：" class="headerlink" title="String 类型："></a>String 类型：</h2><blockquote><p>value除了字符串还可以是数字（计数器、统计多单位数量）</p></blockquote><p>append ‘key’ ‘value’&#x2F;&#x2F;在原有数据的追加value，如果key不存在，相当于set</p><p>incr ‘key’&#x2F;&#x2F; 数据值 +1  </p><p>decr ‘key’&#x2F;&#x2F;数据值 -1</p><p>incrby ‘key’ ‘步长’&#x2F;&#x2F;数据值 +步长</p><p>decrby ‘key’ ‘步长’&#x2F;&#x2F;数据值 -步长</p><p>setex                            &#x2F;&#x2F;set with expire   设置过期时间</p><p>setnx&#x2F;&#x2F;set if not exist不存在则设置（常用在分布式锁）</p><p>mset&#x2F;&#x2F;同时设置多个值</p><p>mget&#x2F;&#x2F;同时获取多个值</p><p>msetnx&#x2F;&#x2F;事务操作，要么同时成功，要么同时失败</p><p>getset&#x2F;&#x2F;先获取值，再设置值</p><hr><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><blockquote><p>在Redis里，可以把list玩成：栈、队列、阻塞队列。</p></blockquote><p>lpush ‘key’ ‘value’&#x2F;&#x2F;将一个或者多个值插入头部（left）</p><p>rpush  ‘key’ ‘value’&#x2F;&#x2F;将一个或者多个值插入尾部（right）</p><p>lrange ‘key’ 0 1&#x2F;&#x2F;通过区间获取具体的值</p><p>lpop ‘key’&#x2F;&#x2F;移除列表 left第一个元素</p><p>rpop ‘key’&#x2F;&#x2F;移除列表 right第一个元素</p><p>lindex ‘key’ 1&#x2F;&#x2F;通过下标获取具体值</p><p>llen&#x2F;&#x2F;获取列表长度</p><p>lrem ‘key’ ‘数量’ ‘value’&#x2F;&#x2F;移除指定的值</p><p>ltrim ‘key’ 1 2&#x2F;&#x2F;通过下标截取list（更改）</p><p>rpoplpush&#x2F;&#x2F;组合命令，移除列表数据，添加到新的列表中</p><p>lset ‘key’ ‘下标’ ‘value’&#x2F;&#x2F;更新指定下标的值（list或对应值 不存在会报错）</p><p>linsert ‘key’ ‘before||after’ ‘原value’ ‘新value’&#x2F;&#x2F;在指定value前或者后插入数据</p><hr><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><blockquote><p>（无序不重复集合）</p></blockquote><p>sadd ‘key’ ‘value’&#x2F;&#x2F;插入数据</p><p>smenbers ‘key’&#x2F;&#x2F;查看集合中的元素</p><p>scard ‘key’&#x2F;&#x2F;获取set集合中元素个数</p><p>srem ‘key’ ‘value’&#x2F;&#x2F;删除指定的值</p><p>srandmember ‘key’ ‘数量’&#x2F;&#x2F;随机取出指定数量的值</p><p>spop ‘key’&#x2F;&#x2F;随机删除元素</p><p>smove ‘key’ ‘newKey’ ‘value’&#x2F;&#x2F;移动数据到新的key中</p><p>sinter ‘key1’ ‘key2’&#x2F;&#x2F;交集</p><p>sdiff ‘key1’ ‘key2’&#x2F;&#x2F;差集</p><p>sunion ‘key1’ ‘key2’&#x2F;&#x2F;并集</p><hr><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><blockquote><p>(key-Map 数据)</p></blockquote><p>hset ‘key’ ‘field’ ‘value’&#x2F;&#x2F;存值</p><p>hget ‘key’ ‘field’&#x2F;&#x2F;取值</p><p>hgetall ‘key’&#x2F;&#x2F;获取全部数据</p><p>hdel ‘key’ ‘field’&#x2F;&#x2F;删除指定的值</p><p>hlen ‘key’&#x2F;&#x2F;查看数量</p><p>hexists ‘key’ ‘field’&#x2F;&#x2F;判断指定的数据是否存在</p><p>hkeys ‘key’&#x2F;&#x2F;查看map中所有的key</p><p>hvals ‘key’&#x2F;&#x2F;查看map中所有的value</p><hr><h2 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h2><blockquote><p>（有序集合）</p></blockquote><p>zadd ‘key’ ‘score’ ‘value’&#x2F;&#x2F;添加一个值 ，score为排序</p><p>zrange ‘key’ 0 1&#x2F;&#x2F;取值</p><p>zrangebyscore ‘key’  -inf +inf &#x2F;&#x2F;排序取值(按score升序)</p><p>zrevrangebyscore&#x2F;&#x2F;排序取值(按score降序)</p><p>zrem ‘key’ ‘value’&#x2F;&#x2F;删除值</p><p>zcard ‘key’&#x2F;&#x2F;获取元素个数</p><p>（可应用于排行榜等需求）</p><h2 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h2><blockquote><p>Geospatial地理位置</p><p>Hyperloglog基数统计</p><p>Bitmap 位图</p></blockquote><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p><strong>RDB</strong></p><p>数据快照、全量备份</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p><p>默认如下配置：</p><p>#表示900 秒内如果至少有 1 个 key 的值变化，则保存save 900 1#表示300 秒内如果至少有 10 个 key 的值变化，则保存save 300 10#表示60 秒内如果至少有 10000 个 key 的值变化，则保存save 60 10000</p><p><strong>AOF</strong></p><p>一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。</p><p><strong>三种触发机制</strong></p><p>（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p>（2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p>（3）不同no：从不同步</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>ACID：原子性、一致性、隔离性、持久性</p><p>Redis事务本质：一组命令的集合！一个事务所有命令序列化，按顺序执行。</p><p>一次性、顺序性、排他性，执行一系列命令。</p><p>Redis事务没有隔离级别的概念。 </p><p>Redis 单条命令是保证原子性的，但是事务不保证原子性。</p><p>redis的事务：</p><ul><li><p>开启事务（multi）</p></li><li><p>命令入队（……）       &#x2F;&#x2F;入队时命令不会执行</p></li><li><p>执行事务（exec）      &#x2F;&#x2F;按照队伍顺序执行命令</p></li><li><p>取消事务（discard）    &#x2F;&#x2F;事务队列中的命令都不会执行</p><blockquote><p>编译型异常（代码有问题，命令有错），事务中的命令都不会执行</p></blockquote><blockquote><p>运行时异常（1&#x2F;0），其他命令可以正常执行，错误命令抛出异常</p></blockquote></li></ul><h2 id="监控-Watch"><a href="#监控-Watch" class="headerlink" title="监控 Watch"></a>监控 Watch</h2><p>​悲观锁</p><p>​乐观锁</p><p>watch 可以当做Redis的乐观锁操作</p><p><img src="C:\Users\Duo\AppData\Roaming\Typora\typora-user-images\image-20200709162437979.png" alt="image-20200709162437979"></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>info replication#查看当前redis服务信息</p><p>更改redis配置，并启动。默认启动的redis服务都是“主机”。</p><p>开始配置，在从机中配置：slaveof ‘主机host’ ‘主机port’</p><p>（命令行配置的主从配置，从机重启服务后悔变为默认情况）</p><p>slaveof no one#使自己变成主机</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>Jedis 是Redis官方推荐的Java连接工具，使用Java连接Redis中间件。</p><p>Jedis jedis &#x3D; new Jedis(“127.0.0.1”,6379);</p><p>使用jedis对象进行操作，与使用命令类似。</p><p>&#x2F;&#x2F;开启事务</p><p>Transaction multi &#x3D; jedis.multi();</p><p>&#x2F;&#x2F;执行事务</p><p>multi.exec();</p><p>&#x2F;&#x2F;放弃事务</p><p>multi.discard();</p><h1 id="SpringBoot中使用Redis"><a href="#SpringBoot中使用Redis" class="headerlink" title="SpringBoot中使用Redis"></a>SpringBoot中使用Redis</h1><p>1，添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis依赖配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2，配置连接参数</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># Redis服务器地址</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># Redis数据库索引（默认为0）</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span> <span class="hljs-comment"># Redis服务器连接端口</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-comment"># Redis服务器连接密码（默认为空）</span><br>    <span class="hljs-attr">jedis:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span> <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">-1ms</span> <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span> <span class="hljs-comment"># 连接池中的最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 连接池中的最小空闲连接</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">3000ms</span> <span class="hljs-comment"># 连接超时时间（毫秒）</span><br></code></pre></td></tr></table></figure><p>1，自行数据存储</p><p>主要使用redisTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RedisService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 存储数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        stringRedisTemplate.opsForValue().set(key, value);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObject</span><span class="hljs-params">(String key, Object value)</span> &#123;<br>        redisTemplate.opsForValue().set(key, value);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.opsForValue().get(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置超期时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">expire</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> expire)</span> &#123;<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.expire(key, expire, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> &#123;<br>        stringRedisTemplate.delete(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自增操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delta 自增步长</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">increment</span><span class="hljs-params">(String key, <span class="hljs-type">long</span> delta)</span> &#123;<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.opsForValue().increment(key,delta);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2，使用Spring Cache，进行数据缓存。</p><blockquote><p>缓存有多种可以在Dao层实现，也可以在Service层实现</p><p>Dao层实现缓存，根据ORM框架不同，实现方式略有不同，这里推荐Service层缓存</p></blockquote><p>SpringCache缓存功能的实现是依靠下面的这几个注解完成的。</p><ul><li>@EnableCaching：开启缓存功能</li><li>@CacheConfig：定义公共设置，位于class之上</li><li>@Cacheable：定义缓存，用于触发缓存</li><li>@CachePut：定义更新缓存，触发缓存更新</li><li>@CacheEvict：定义清除缓存，触发缓存清除</li><li>@Caching：组合定义多种缓存功能</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCacheConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br>    <span class="hljs-comment">//格式化local日期类 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> JavaTimeModule <span class="hljs-title function_">getJavaTimeModule</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">JavaTimeModule</span> <span class="hljs-variable">javaTimeModule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaTimeModule</span>();<br>        javaTimeModule.addSerializer(LocalDateTime.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));<br>        javaTimeModule.addSerializer(LocalDate.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)));<br>        javaTimeModule.addSerializer(LocalTime.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>)));<br>        javaTimeModule.addDeserializer(LocalDateTime.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)));<br>        javaTimeModule.addDeserializer(LocalDate.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)));<br>        javaTimeModule.addDeserializer(LocalTime.class,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));<br>        <span class="hljs-keyword">return</span> javaTimeModule;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisSerializer&lt;Object&gt; <span class="hljs-title function_">redisSerializer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//创建JSON序列化器</span><br>        <span class="hljs-comment">//Use Jackson 2Json RedisSerializer to serialize and deserialize the value of redis (default JDK serialization)</span><br>        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>        <span class="hljs-comment">//设置日期时间格式化</span><br>        objectMapper.registerModule(TimeUtil.getJavaTimeModule()).registerModule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterNamesModule</span>());<br><br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        <span class="hljs-comment">//将类名称序列化到json串中</span><br>        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);<br>        <span class="hljs-comment">//设置输入时忽略JSON字符串中存在而Java对象实际没有的属性</span><br>        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-literal">false</span>);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>        <span class="hljs-keyword">return</span> jackson2JsonRedisSerializer;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>        RedisSerializer&lt;Object&gt; serializer = redisSerializer();<br>        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(connectionFactory);<br><br>        <span class="hljs-comment">//Use String RedisSerializer to serialize and deserialize the key value of redis</span><br>        <span class="hljs-type">RedisSerializer</span> <span class="hljs-variable">redisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-comment">//key</span><br>        redisTemplate.setKeySerializer(redisSerializer);<br>        redisTemplate.setHashKeySerializer(redisSerializer);<br>        <span class="hljs-comment">//value</span><br>        redisTemplate.setValueSerializer(serializer);<br>        redisTemplate.setHashValueSerializer(serializer);<br><br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">//使用redis做缓存器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisCacheManager <span class="hljs-title function_">redisCacheManager</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-type">RedisCacheWriter</span> <span class="hljs-variable">redisCacheWriter</span> <span class="hljs-operator">=</span> RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);<br>        <span class="hljs-comment">//设置Redis缓存有效期为1天</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">redisCacheConfiguration</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig()<br>                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCacheManager</span>(redisCacheWriter, redisCacheConfiguration);<br>    &#125;<br>    <br>    <span class="hljs-comment">//</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SimpleCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleCacheManager</span>();<br>        cacheManager.setCaches(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentMapCache</span>(<span class="hljs-string">&quot;default&quot;</span>)));<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(value = &quot;schoolInfo&quot;, key = &quot;&#123;#sid&#125;+&#x27;-&#x27;+&#123;#name&#125;&quot;, unless = &quot;#result eq null&quot;)</span><br><br></code></pre></td></tr></table></figure><p>3，格式化储存数据，自定义RedisTemplate以Json格式进行缓存。(代码案例如上)</p><hr><h2 id="Redis问题排查"><a href="#Redis问题排查" class="headerlink" title="Redis问题排查:"></a>Redis问题排查:</h2><p>在spring-boot-starter-data-redis中是使用lettuce做连接,发现报错:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">org.springframework.data.redis.RedisSystemException: Redis exception; nested exception is io.lettuce.core.RedisException: java.io.IOException: Connection reset by peer<br></code></pre></td></tr></table></figure><p>一种解决方案:  修改你的 Redis 服务端配置</p><ol><li><p>修改前，我们先查看 Redis 配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 查看当前连接数<br>127.0.0.1:6379&gt; info clients<br># Clients<br>connected_clients:3<br>client_recent_max_input_buffer:8<br>client_recent_max_output_buffer:0<br>blocked_clients:0<br>tracking_clients:0<br>clients_in_timeout_table:0<br># 查看超时<br>127.0.0.1:6379&gt; config get time*<br>1) &quot;timeout&quot;<br>2) &quot;0&quot;<br># 查看最大存活时间<br>127.0.0.1:6379&gt; config get tcp*<br>1) &quot;tcp-keepalive&quot;<br>2) &quot;300&quot;<br>3) &quot;tcp-backlog&quot;<br>4) &quot;511&quot;<br># 查看最大客户端数<br>127.0.0.1:6379&gt; config get maxc*<br>1) &quot;maxclients&quot;<br>2) &quot;10000&quot;<br></code></pre></td></tr></table></figure></li><li><p>修改 Redis 配置（临时生效，重启 Redis 失效，想持久有效可修改配置文件）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 最大连接数 3W<br>config set maxclients 30000<br><br># 超时时间 300 秒<br>config set timeout 300<br><br># 最大存活时间 60 秒<br>config set tcp-keepalive 60<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>褪去了职场新手光环的我，该何去何从？</title>
      <link href="/2019/02/01/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02019%E5%B9%B42%E6%9C%88%E6%9F%90%E6%97%A5/"/>
      <url>/2019/02/01/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02019%E5%B9%B42%E6%9C%88%E6%9F%90%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="褪去了职场新手光环的我，该何去何从？"><a href="#褪去了职场新手光环的我，该何去何从？" class="headerlink" title="褪去了职场新手光环的我，该何去何从？"></a>褪去了职场新手光环的我，该何去何从？</h1><p>昨天和同事谈到，“想当年”上学的时候，她对这个字眼还表示好笑。好笑么？我觉得可以用这个次形容了吧。转眼已经毕业两年了，女朋友比我小两届，现在正是她准备回学校忙毕业的时间，电话里她和同学谈论的学校相关的事，仿佛和我并没有什么关系了，我也不再能作为一个学长帮助她们一些什么了。她们马上也会像我两年前一样的离开校园，初入职场。</p><p>​        2015年的时候，我在北京实习，很高兴认识了我第一位老板，他对我的培养和照顾都很多，可能这也是对一个新人的特殊优待吧。他给过我很多的经验建议，也曾推荐我去寻求一些圈子内其他大咖的指导。那时候，尽管我初出茅庐，但是大咖们对有着求知欲，可塑性的我，还是很耐心的。      </p><p>​        2016年夏，我正式离开学校，也离开了第一份工作，选择了到苏州来工作。因为找工作并不是第一次了，所以来到之后的求职之路并不是十分慌乱。反而是归属感的问题，一个人，在一个陌生的城市，真的很不安。一切安顿妥当之后，我选择了一家互联网幼教的公司工作，而这一干就是两年。 其实两年的时间不应该用这种语气来描述。之所以这么说，是因为两年后的今天，我心里觉得这两年并没有做成什么，也没觉得自己成长了多少。今天早上看公众号推文评论中，某大神的徒弟求师父内推工作，当得知该大神也在苏州时。我一下子就想到了前老板对我讲的“要融入你行业的圈子，这对你的成长很重要”。很想约大神见面聊一聊获得一些指导。但是想一下自己现在的情况，或许大神也不屑和我一聊了吧。果然，在初入职场的庇护下，如果没能快速成长起来，很多资源就不再那么容易得到了。</p><p>那天看见了一件事，也挺有感触。</p><p>B问A：“现在开始做***，还来不来得及？”  </p><p>A回答：“来不及也得做啊，难道现在来不及，以后就来得及？你这个人真奇怪”。</p><p>这是个被说烂掉的道理，但是不知怎么，在两个看似不务正业的人嘴里说出来，就很发人深省。</p><p>回顾两年间，有时懒懒散散，有时忙忙碌碌（没什么成就也就算瞎忙了）。现在在公司看似举足轻重，却又可有可无。整日存活在慌乱，迷茫中。比如今天，写了这么多文字，也不知道想表达什么。其实说到底，也就是真实的记录一下自己内心对自己的判断，不存在客观与否。只是一个观念，如果觉得自己没有达到更好，那就去做。</p><p>最后记下一句最近时常在脑袋里回荡的一句话：“当你觉得自己从未放弃过的时候，仔细想一下自己到底在坚持着些什么？”</p>]]></content>
      
      
      <categories>
          
          <category> 心情随记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用记录_Linux和Docker</title>
      <link href="/2018/11/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Linux%E5%92%8CDocker/"/>
      <url>/2018/11/01/%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Linux%E5%92%8CDocker/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>为了补充项目开发后部署和运维相关能力，通过自建Linux服务器学习一些相关知识。</p><p>（因为过程中包含“白嫖”等可耻行为，所以只记录，不发布）</p><h2 id="一、安装CentOS7"><a href="#一、安装CentOS7" class="headerlink" title="一、安装CentOS7"></a>一、安装CentOS7</h2><p>准备：闲置笔记本一台（可以使用虚拟机代替，如果使用云服务器，直接跳过前三章节）</p><p>下载镜像：<a href="https://mirrors.aliyun.com/centos/7/isos/%EF%BC%88%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E7%AB%99%E4%B8%8B%E8%BD%BD%EF%BC%89">https://mirrors.aliyun.com/centos/7/isos/（通过阿里云镜像站下载）</a></p><p>这里使用centos7,常见镜像版本：</p><p>DVD — 标准版（含桌面）,约4.5个G，新手上路，我选择这个。 </p><p>Minimal — mini版，（不含桌面），约1个G。</p><p>通过UltraISO写入硬盘系统镜像（据说用9.3.6版及以前的会出问题，这里我选择试用最新版，中途无问题，没做排错记录）</p><p>接下来，通过写入镜像的U盘给笔记本重做系统，（这里因为是闲置笔记本，所以是硬盘完全格式化，重做单Linux系统。如果打算双系统或者使用虚拟机，操作略有不同，这里不做过多介绍。）</p><p>过程: 通过U盘启动后，可选择Install CentOS 7，按“E”，进入编辑。</p><p>将</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">setparams &#x27;Install CentOS Linux 7&#x27; <br>linuxefi /images/pxeboot/vmlinuz inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 xdriver=vesa nomodeset quiet<br>initrdefi /images/pxeboot/initrd.img<br></code></pre></td></tr></table></figure><p>变为</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">setparams &#x27;Install CentOS Linux 7&#x27; <br>linuxefi /images/pxeboot/vmlinuz linux dd nomodeset quiet<br>initrdefi /images/pxeboot/initrd.img<br></code></pre></td></tr></table></figure><p>Ctrl+X执行，然后屏幕上就会列出硬盘设备的详细信息，我们从列表中挑出当前作为介质的U盘的代码（比如sda4）,然后重起系统,再次进入编辑，修改内容(注意修改成自己的U盘代码)</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">setparams &#x27;Install CentOS Linux 7&#x27;<br>linuxefi /images/pxeboot/vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4 quiet<br>initrdefi /images/pxeboot/initrd.img<br></code></pre></td></tr></table></figure><p>然后Ctrl+X执行，即可进入图形化安装界面。</p><p>DVD镜像，默认基本环境是最小化安装（无桌面），所以这里手动选择一些带GUI的服务器。</p><p>等待系统安装完成，创建账户，进入系统。截止到写笔记的日期，本人仍然为Linux操作新手，基本指令还需要摸索着来，所以选择了带桌面系统，并且切换为root用户进行操作。</p><p>注意，由于是笔记本安装系统做服务器，需要修改一下笔记本合盖时系统状态：</p><p>修改  &#x2F;etc&#x2F;system&#x2F;logind.conf     取消HandleLidSwitch&#x3D;suspend改行注释，并将suspend修改为lock。</p><p>至此，一个常规的Linux系统的机器算是装完了。接下来开始边学边用。</p><p>执行命令：lsblk 进行查看 硬盘情况</p><h2 id="二、配置连接"><a href="#二、配置连接" class="headerlink" title="二、配置连接"></a>二、配置连接</h2><p>本人目前并不能很好的掌握Linux系统的常规使用，但是在之前对一些工具有所耳闻，此篇章用于记录工具配置。</p><blockquote><p>1，SSH连接工具：</p><p>FinalShell。</p><p>Xshell,Xftp。连接Linux系统的和文件传输的软件，官方提供家庭和学校的免费下载链接。</p><p>宝塔也有SSH终端，知名度不高，这里不选择使用。</p><p>SecureCRT,SecureFX。</p><p>Termius。 mac上使用这个，所以windows上也选择了这个。</p><p>（目前只是简单使用，差距并未体验到，所以可以按喜好选择）</p></blockquote><blockquote><p>由于家里和办公室都无法通过外网访问，所以分别在台式机，笔记本，Linux系统笔记本上安装了ZeroTier，这里就可以通过自己工作环境通过分配的虚拟IP直接连接到Linux服务器了，花生壳配置对应端口的内网映射，可以将服务器的对应内容开放外网访问，以后服务器部署项目后又用。</p></blockquote><p>至此，一台自己可用的Linux服务器已经搭建完成了。</p><p>通过Xshell连接虚拟IP后，可以通过指令操作服务器了。</p><h2 id="三、Linux"><a href="#三、Linux" class="headerlink" title="三、Linux"></a>三、Linux</h2><blockquote><p>Linux的世界里，一切皆文件。</p></blockquote><p>Linux目录结构：级层式树状目录结构</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@duo /]# ls<br>bin  boot  dev  etc  home  install.sh  lib  lib64  media  mnt  mydata  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  www<br></code></pre></td></tr></table></figure><p>&#x2F;bin常用指令目录</p><p>&#x2F;dev设备管理</p><p>&#x2F;etc 配置文件</p><p>&#x2F;home创建普通用户后，会在这里生成对应的文件</p><p>&#x2F;root  系统管理员目录</p><p>&#x2F;lib动态库</p><p>&#x2F;usr&#x2F;local用户安装的很多应用程序都在这个目录</p><p>&#x2F;boot启动Linux时使用的一些文件</p><p>&#x2F;mnt临时挂载的别的文件系统</p><p>&#x2F;var目录中存放着不断扩充的文件，习惯将经常修改的目录放在这里，包括各种日志文件</p><h3 id="实操篇"><a href="#实操篇" class="headerlink" title="实操篇"></a>实操篇</h3><h4 id="vi和vim编辑器"><a href="#vi和vim编辑器" class="headerlink" title="vi和vim编辑器"></a>vi和vim编辑器</h4><p>Linux内置vi编辑器，Vim具有程序编辑能力，相当于vi的增强版。</p><p>vi和vim的三种模式：</p><p>1，正常模式：打开默认这种模式，其他模式状态按ESC返回该模式。可以使用快捷键。</p><p>2，插入&#x2F;编辑模式： 按i启动，</p><p>3，命令行模式：按:启动该模式，可以使用命令来完成 读取、存盘、替换、离开 等操作。</p><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/vi.png"></p><p>快捷键：</p><p>拷贝当前行：yy拷贝下面5行：5yy</p><p>粘贴：p</p><p>删除</p><p>删除当前行：dd删除下面3行：3dd</p><p>撤销操作：u</p><p>文件中查询单词(命令行下 )：&#x2F;关键字  ，回车 。    输入n 就是查找下一个</p><p>显示行号(命令行下 )：set nu隐藏行号：set nonu</p><p>快速到达末行：G首行：gg</p><p>移动到指定行：1，显示行号2，输入目标行数3，输入G或者gg</p><h4 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h4><p><strong>关机重启：</strong></p><p>shutdown -h now：表示立即关机 halt</p><p>shutdown -h 1：表示1分钟后关机</p><p>shutdown -r now：立即重启reboot</p><p>sync：把内存数据同步到硬盘，推荐关机或重启前执行一下。</p><p><strong>用户登录和注销：</strong></p><p>1，尽可能少用root账号登录，系统管理员权限过大，避免误操作造成损失。</p><p>推荐使用普通用户登录，可以通过“su - 用户名”来切换成系统管理员身份</p><p>2，logout 注销登录</p><p><strong>用户管理：</strong></p><p>1，添加一个用户：useradd &lt;用户名&gt;</p><p>会在&#x2F;home目录下创建 用户名的文件夹，并且默认情况 会让该用户加入同名用户组</p><p>useradd -g &lt;用户组名&gt; &lt;用户名&gt;，将用户指定到目标用户组</p><p>2，指定用户的密码：passwd &lt;用户名&gt;</p><p>回车之后输入密码。</p><p>3，删除一个用户：userdel &lt;用户名&gt;</p><p><strong>文件目录管理</strong></p><p>pwd：查看当前目录绝对路径</p><p>ls：查看当前目录下的内容-a 显示所有   -l 以列表方式显示</p><p>cd &lt;目标路径&gt;：前往目标路径。~ 自己的家.. 上一级</p><p>mkdir：创建目录-p 创建多级目录</p><p>touch：创建空文件</p><p>cp &lt;源目录&gt; &lt;新目录&gt;：拷贝文件到指定目录-r 递归复制整个文件夹</p><p>rm：删除文件或目录-r 递归删除-f 强制删除不提示</p><p>mv：移动或重命名（目录相同为重命名，目录不同为移动）</p><p>cat：查看文件-n 显示行号         （只读，通常与more一起使用  cat -n &lt;文件&gt; | more）</p><p>more：分页查看文件（空格键  翻页，Ctrl+B 上一页，Ctrl+F下一页）</p><p>less：分页查看文件，不是全部加载，而是根据显示内容加载，大文件效率高</p><p>head：显示文件开头部分内容，默认显示10行-n 5 显示前5行（数字可变）</p><p>tail：显示文件末尾部分内容，默认显示10行-n 5 显示最后5行-f 实时追踪文档更新</p><p>&gt;：输出重定向（覆盖写入）</p><p>&gt;&gt;：追加写入</p><p>echo：输出内容到控制台</p><p>ln：软链接，类似于快捷方式ln -s &lt;源文件&gt; &lt;软链接名&gt;</p><p>history：查看执行过的历史命令history 10 查看最近的10条命令!10 执行编号10的命令</p><p><strong>时间日期类：</strong></p><p>date：显示当前日期+%Y显示当前年+%m显示当前月+%d显示当前日</p><p>date “+%Y-%m-%d %H:%M:%S”按格式显示时间，连接符可以自己定</p><p>date -s “2020-02-02 02:02:02”设置时间</p><p>cal：以日历的方式显示时间cal 2020 显示一整年日历</p><p><strong>搜索查找类</strong></p><p>find：从指定目录内遍历搜索，将符合的文件显示在终端。</p><p>find &lt;目录&gt; -name &lt;文件名&gt;在目录下 按文件名查询，可以使用通配符</p><p>find &lt;目录&gt; -user &lt;用户名&gt;按文件所属用户进行查找</p><p>find &lt;目录&gt; -size &lt;文件大小限制&gt;按文件大小限制查找，+n 大于，-n小于，n等于</p><p>grep：过滤查找</p><p>| ：管道符号，将前一个命令的结果传递给后一个命令处理</p><p><strong>压缩和解压</strong></p><p>gzip &lt;文件&gt;：压缩文件后缀 .gz    只压缩文件不压缩目录，不保留原文件<br>gzip -d &lt;文件&gt;： 解压文件</p><p>tar： 打包同时压缩  后缀 .tar.gz 可打包压缩文件目录，保留原文件</p><p>zip &lt;文件&gt;： 压缩文件或目录后缀 .zip 与tar类似，压缩后可被windows识别<br>unzip &lt;文件&gt;： 解压文件或目录</p><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><blockquote><p>Linux中的每个用户必须属于一个组，不能独立于组外。</p><p>在Linux中每个文件有 所有者、所在组，其他组的概念。</p></blockquote><p>1，ls -ahl：查看文件或目录所有者、所在组</p><p>2，chown &lt;用户名&gt; &lt;文件名&gt;修改文件所有者，并不改变所在组</p><p>3，groupadd &lt;组名&gt;：创建一个组</p><p>4，chgrp &lt;组名&gt; &lt;文件名&gt;：修改文件所在组</p><p>5，usermod -g &lt;组名&gt; &lt;用户名&gt;：改变用户所在组</p><p>6，usermod -d &lt;目录名&gt; &lt;用户名&gt;：改变用户登录的初始目录</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@duo mydata]# ls -l<br>total 1900<br>drwxr-xr-x. 5 root root      41 Jul 13 12:40 mysql<br>drwxr-xr-x. 5 root root      42 Jul 13 12:38 nginx<br>-rw-r--r--. 1 ljd  ljd  1941868 Jul 13 11:25 pgyvpn.rpm<br>drwxr-xr-x. 5 root root      46 Jul 14 09:36 redis<br>drwxr-xr-x. 3 root root      21 Jul 20 16:03 tomcat<br></code></pre></td></tr></table></figure><p>0~9位说明：</p><p>第0位：确定文件类型（d:目录，-:普通文件，l:链接文件，c:字符设备，b:块文件）</p><p>第1-3位：所有者权限（r:读权限，w:写权限，-:无权限，x:执行权限）</p><p>第4-6位：所属组权限</p><p>第7-9位：其他用户权限</p><p>.后面数字：目录下文件数</p><p>所有者</p><p>所在组</p><p>文件大小</p><p>文件最后修改时间</p><p><strong>修改权限</strong></p><p>chmod：修改权限chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录名</p><p>（u:所有者，g:所在组，o:其他人，a:所有人）</p><p>（使用+、-、&#x3D;变更权限）</p><p>（还可以通过数字变更权限：r&#x3D;4，w&#x3D;2，x&#x3D;1）</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>1，crond：任务调度-e:编辑，-l:显示，-r:删除</p><h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p><strong>分区的基础概念</strong></p><p>1，mbr分区（最多四个主分区，最大支持2TB）</p><p>2，gpt分区（支持无限多分区，但是可能被操作系统限制，最大支持18EB）</p><p><strong>Linux分区介绍</strong></p><p>无论多少个分区，都挂载在根目录。分区只是组成整个文件系统的一部分。</p><p>Linux硬盘分为IDE硬盘和SCSI硬盘，目前基本都是SCSI硬盘。</p><p>SCSI硬盘的标识符为“sdx<del>”，sd 表示分区所在设备类型，x表示盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）</del>表示分区，1-4是主分区或扩展分区，从5开始时逻辑分区。</p><p>lsblk查看分区挂载情况</p><p><strong>添加一块硬盘</strong></p><p>1，虚拟机添加硬盘</p><p>2，分区fdisk &#x2F;dev&#x2F;sdb</p><p>3，格式化mkfs -t ext4 &#x2F;dev&#x2F;sdb1</p><p>4，挂载目录先创建一个目录，然后挂载 mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk</p><p>5，设置自动挂载</p><p>vi &#x2F;etc&#x2F;fstab 按规则编辑配置文件，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/dev/mapper/centos-root /                         xfs  defaults  0 0<br>UUID=58f6c38d-be8f-4787-b25d-2331aac9843a  /boot  xfs  defaults  0 0<br>/dev/mapper/centos-swap swap                      swap  defaults  0 0<br>/dev/sdb1  /mydata/newdisk                        ext4  defaults  0 0<br></code></pre></td></tr></table></figure><p> mount -a 生效</p><p><strong>磁盘情况查询</strong></p><p>df -h ：查询整个系统磁盘使用情况</p><p>du -h &lt;目录&gt;：查询指定目录磁盘占用情况–max-depth&#x3D;2 子目录深度</p><h3 id="Centos调整分区存储大小"><a href="#Centos调整分区存储大小" class="headerlink" title="Centos调整分区存储大小"></a>Centos调整分区存储大小</h3><p>例如：将&#x2F;home下150G 转移到&#x2F; 目录下</p><p>fdisk -l</p><p>查看待挂载硬盘</p><p>&#x2F;dev&#x2F;sda 274.9 GB<br>查看物理卷<br>&#x2F;dev&#x2F;mapper&#x2F;centos-root 53.7 GB<br>&#x2F;dev&#x2F;mapper&#x2F;centos-home 212.1 GB</p><p>1、查看分区大小：df -hl<br>2、备份home文件：tar cvf &#x2F;run&#x2F;home.tar &#x2F;home<br>3、终止home文件进程（切换到非home路径下执行这个命令）：fuser -km &#x2F;home<br>4、卸载home：umount &#x2F;home<br>5、删除home所在逻辑卷：lvremove &#x2F;dev&#x2F;mapper&#x2F;centos-home<br>6、扩大根目录所在的逻辑卷：lvextend -L +150G &#x2F;dev&#x2F;mapper&#x2F;centos-root<br>7、同步文件：xfs_growfs &#x2F;dev&#x2F;mapper&#x2F;centos-root<br>8、重建&#x2F;home文件系统所需要的逻辑卷：lvcreate -L 44G -n &#x2F;dev&#x2F;mapper&#x2F;centos-home<br>9、创建文件系统：mkfs.xfs &#x2F;dev&#x2F;mapper&#x2F;centos-home<br>10、挂载&#x2F;home文件系统：mount &#x2F;dev&#x2F;mapper&#x2F;centos-home<br>11、恢复&#x2F;home目录的内容：tar xvf &#x2F;run&#x2F;home.tar -C &#x2F;<br>12、删除&#x2F;run下面的备份home文件：rm -rf &#x2F;run&#x2F;home.tar</p><h3 id="Linux虚拟机增加磁盘大小后如何扩展现有目录空间"><a href="#Linux虚拟机增加磁盘大小后如何扩展现有目录空间" class="headerlink" title="Linux虚拟机增加磁盘大小后如何扩展现有目录空间"></a>Linux虚拟机增加磁盘大小后如何扩展现有目录空间</h3><p>例如：lsblk 查看磁盘情况，如何把 sda 中剩余空间 增加到&#x2F;home文件夹？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sda                                        8:0    0   500G  0 disk  <br>├─sda1                                     8:1    0   500M  0 part /boot <br>└─sda2                                     8:2    0 255.5G  0 part  <br>  ├─centos-root                            253:0    0    50G  0 lvm  / <br>  ├─centos-swap                            253:1    0   7.9G  0 lvm  [SWAP] <br>  └─centos-home                            253:2    0 197.6G  0 lvm  /home <br></code></pre></td></tr></table></figure><p>步骤1，你可以使用分区管理工具如fdisk或parted来创建新的分区。我将展示如何使用fdisk命令创建新的分区：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fdisk /dev/sda<br># 现在你将看到sda的分区表信息。输入 n 来创建一个新分区。<br># 选择分区类型。如果你只需将剩余空间用于LVM，你可以选择 p 来创建一个主分区。<br># 确定新分区的起始扇区和大小。如果你只需使用默认值以使用整个未分配空间，可以连续按 Enter 键。<br># 输入 w 来保存并退出。<br></code></pre></td></tr></table></figure><p>步骤2，**将新的分区标记为物理卷(PV)**：使用<code>pvcreate</code>命令将新创建的分区标记为物理卷。</p><p>(如果提示Device &#x2F;dev&#x2F;sda3 not found.，是因为系统没有识别到新的分区，需要<code>partprobe</code>重新加载一下。 )</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">pvcreate /dev/sda3<br></code></pre></td></tr></table></figure><p>步骤3，**将新的物理卷添加到卷组(VG)**：使用<code>vgextend</code>命令将新创建的物理卷添加到现有的卷组中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vgextend centos /dev/sda3<br></code></pre></td></tr></table></figure><p>步骤4，**扩展逻辑卷(LV)**：使用<code>lvextend</code>命令将&#x2F;home逻辑卷扩展到新的物理卷上。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">lvextend -L +194G /dev/mapper/centos-home<br></code></pre></td></tr></table></figure><p>步骤5，<strong>重新调整文件系统大小</strong>：根据文件系统类型使用适当的工具调整文件系统大小。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">xfs_growfs /dev/mapper/centos-home<br></code></pre></td></tr></table></figure><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>修改配置文件指定固定IP地址，centos7的网络IP地址配置文件在 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts 文件夹下，ens33网卡对应的配置文件为ifcfg-ens33</p><p>vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TYPE=&quot;Ethernet&quot;<br>PROXY_METHOD=&quot;none&quot;<br>BROWSER_ONLY=&quot;no&quot;<br>BOOTPROTO=&quot;static&quot;# 使用静态IP地址，默认为dhcp<br>DEFROUTE=&quot;yes&quot;<br>IPV4_FAILURE_FATAL=&quot;no&quot;<br>IPV6INIT=&quot;yes&quot;<br>IPV6_AUTOCONF=&quot;yes&quot;<br>IPV6_DEFROUTE=&quot;yes&quot;<br>IPV6_FAILURE_FATAL=&quot;no&quot;<br>IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;<br>NAME=&quot;ens33&quot;<br>UUID=&quot;223fbfe1-8732-4032-9cc5-c030dd70b250&quot;<br>DEVICE=&quot;ens33&quot;<br>ONBOOT=&quot;yes&quot;#是否开机启用<br>IPADDR=&quot;192.168.0.58&quot;# 设置的静态IP地址<br>NETMASK=&quot;255.255.255.0&quot;# 子网掩码<br>GATEWAY=&quot;192.168.0.1&quot;# 网关地址<br>DNS1=&quot;119.29.29.29&quot;# DNS服务器<br></code></pre></td></tr></table></figure><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>1，ps：查看目前系统中哪些正在执行，正在执行的情况</p><p>ps -a：显示当前终端的所有进程信息</p><p>ps -u：以用户的格式显示进程信息</p><p>ps -x：显示后台进程运行的参数</p><p>2，kill：终止进程</p><p>kill &lt;选项&gt; &lt;进程号&gt; ：通过进程号杀死进程。</p><p>-9：强制终止</p><p>killall &lt;进程名称&gt;：通过进程名称杀死进程，支持通配符。</p><p>3，pstree：查看进程树-p 显示进程PID-u显示进程所属用户</p><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><blockquote><p>服务（service）本质就是线程，但是运行在后台，通常会监听某一端口，等待其他程序请求</p></blockquote><p>systemctl &lt;服务名&gt;  [start|stop|restart|reload|status]  ：操作某一服务</p><p>systemctl enable &lt;服务名&gt;：设置服务开机启动</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>top：监控进程，默认3秒刷新一次</p><p>netstat -anp：监控网络</p><h3 id="RPM和YUM"><a href="#RPM和YUM" class="headerlink" title="RPM和YUM"></a>RPM和YUM</h3><blockquote><p>RPM（Red-Hat Package Manager）</p></blockquote><p>rpm -qa | grep &lt;软件包名称&gt;：查询软件包是否安装</p><p>rpm -qi &lt;软件包名称&gt;：查询软件安装详情</p><p>rpm -ql &lt;软件包名称&gt;：查询软件包中的文件所在位置</p><p>rpm -qf &lt;文件名&gt;：查询文件属于哪个软件包</p><p>rpm -e &lt;软件包名称&gt;：卸载软件包</p><p>rpm -ivh &lt;软件包全路径名称&gt;：安装软件包install 安装verbose 提示hash 进度条</p><blockquote><p>Yum是一个shell前端的软件包管理器。能够从指定远程服务器自动下载包rpm包并安装，并且一次性安装所有依赖。</p></blockquote><p>yum list | grep &lt;软件名&gt;：查询yum服务器上有没有这个软件</p><p>yum install &lt;软件名&gt;：安装软件，默认安装最新版本</p><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><blockquote><p>shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至编写一些程序。</p></blockquote><p>快速入门：</p><p>1，脚本以#!&#x2F;bin&#x2F;bash开头</p><p>2，脚本需要有执行x权限</p><p>3，无执行权限 可以通过 sh &lt;脚本文件&gt;，来执行。</p><h2 id="四、Docker"><a href="#四、Docker" class="headerlink" title="四、Docker"></a>四、Docker</h2><p>开发者学运维，基本都是项目部署驱动学习方向，所以，学Docker是目标，Linux是前置技术，边学边掌握。虽然Windows上也可以用Docker，但是还是跟随主流吧。</p><p>1，安装Docker，官网已经很详细了。按照步骤执行对应指令即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shel">yum install -y yum-utils<br><br>yum-config-manager \<br>    --add-repo \<br>    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>#这里已经 替换为阿里云的镜像地址<br><br>yum makecache fast<br><br>yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>2，配置阿里云容器镜像加速</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs she">sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://z5mv7pwy.mirror.aliyuncs.com&quot;],<br>  &quot;bip&quot;: &quot;192.168.200.1/24&quot;<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>这里是按照阿里云服务器的容器镜像加速配置进行配置，由于我用的自建Linux系统，配置后是否有加速效果，还未考证。</p><h4 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h4><h6 id="1，宿主机无法访问容器里的服务"><a href="#1，宿主机无法访问容器里的服务" class="headerlink" title="1，宿主机无法访问容器里的服务"></a>1，宿主机无法访问容器里的服务</h6><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl http://127.0.0.1<br>报错curl: (56) Recv failure: Connection reset by peer<br></code></pre></td></tr></table></figure><p>原因：docker网卡地址冲突   (其中： brctl命令需要安装： yum install -y bridge-utils)</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo service docker stop<br>sudo ip link set dev docker0 down            %关闭docker虚拟网卡<br>sudo brctl delbr docker0<br>sudo iptables -t nat -F POSTROUTING<br>sudo brctl addbr docker0<br>sudo ip addr add 192.168.200.1/24 dev docker0<br>sudo ip link set dev docker0 up %开启docker虚拟网卡<br>vi /etc/docker/daemon.json<br><span class="hljs-meta prompt_">#</span><span class="language-bash">daemon.json</span><br>&#123;&quot;registry-mirrors&quot;: [&quot;http://224ac393.m.daocloud.io&quot;],<br>    &quot;bip&quot;: &quot;192.168.200.1/24&quot;<br>&#125;<br><br>systemctl  restart  docker<br></code></pre></td></tr></table></figure><h6 id="2，宿主机映射docker容器端口后，宿主机防火墙未开放该端口，外网仍然可以访问。"><a href="#2，宿主机映射docker容器端口后，宿主机防火墙未开放该端口，外网仍然可以访问。" class="headerlink" title="2，宿主机映射docker容器端口后，宿主机防火墙未开放该端口，外网仍然可以访问。"></a>2，宿主机映射docker容器端口后，宿主机防火墙未开放该端口，外网仍然可以访问。</h6><p>linux  有两种防火墙：iptables    和   firewall，一般用宝塔或者下面命令都是在firewall中开启对应端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=8080/tcp --permanent<br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><p>原因：docker run新容器的时候 在iptables 新建规则，将容器映射端口开放给0.0.0.0&#x2F;0  （所有）</p><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/iptables.jpg"> </p><p>如果想要关闭公网访问 需要手动 删除规则</p><p>iptables -D DOCKER 2</p><p>iptables -D DOCKER 3</p><p>3,学习常用的Docker命令</p><p><img src="https://gitee.com/duo-ge/duo-ge/raw/pic/%E5%9B%BE%E7%89%87%E5%BA%93/Docker%E5%91%BD%E4%BB%A4%E5%9B%BE%E8%B0%B1.jpg"></p><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 8088:9000 \<br>--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer<br></code></pre></td></tr></table></figure><h4 id="容器的数据卷使用——MySQL同步数据"><a href="#容器的数据卷使用——MySQL同步数据" class="headerlink" title="容器的数据卷使用——MySQL同步数据"></a>容器的数据卷使用——MySQL同步数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<br></code></pre></td></tr></table></figure><h4 id="Dockerfile-和-docker-compose-yml的区别"><a href="#Dockerfile-和-docker-compose-yml的区别" class="headerlink" title="Dockerfile 和 docker-compose.yml的区别"></a>Dockerfile 和 docker-compose.yml的区别</h4><blockquote><p>Dockerfile 是拿来构建自定义镜像的，并没有直接生成容器。</p><p>docker-compose.yml 文件是做容器编排以部署环境，里面包含使用各种镜像创建的容器服务，使用的镜像可以是网络上的，也可以是根据使用Dockerfile文件来生成的镜像。</p></blockquote><h5 id="Dockerfile（脚本）"><a href="#Dockerfile（脚本）" class="headerlink" title="Dockerfile（脚本）"></a>Dockerfile（脚本）</h5><p><a href="https://mp.weixin.qq.com/s/U_OcNMpLAJJum_s9jbZLGg">使用Dockerfile为SpringBoot项目构建docker镜像</a></p><p>Dockerfile 部分指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// FROM 指定基础镜像<br>FROM nginx<br><br>// RUN 执行命令。每一条 RUN 都会生成一层，一个需求尽量使用&amp;&amp;，这样就减少了 RUN ，即减少了分层<br>RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html<br>RUN yum update &amp;&amp; yum install -y vim python-dev<br><br>// COPY: 源路径下的 package.json 复制到新一层的镜像路径/usr/src/app<br>COPY package.json /usr/src/app/<br><br>// WORKDIR 指定工作目录。指定下层工作的目录为容器内的/data,尽量使用绝对目录<br>WORKDIR /data<br><br>// ADD 添加，ADD能自动解压文件。以下例子最终 hello 在/data/test 下<br>WORKDIR /data<br>ADD hello test/ <br><br>// COPY 拷贝  与ADD类似，只是不能解压缩文件。<br>WORKDIR /DATA<br>COPY hello test/<br><br>// CMD 执行命令<br>CMD [&quot;python&quot;, &quot;app.py&quot;]<br><br>// ENV 设置环境变量 定义 NAME=Happy Feet,那么之后就可以使用 $NAME 来执行了 <br>ENV VERSION=1.0 DEBUG=on NAME=&quot;Happy Feet&quot; // VOLUMES挂载<br><br>// EXPOSE 端口暴露 <br>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]<br></code></pre></td></tr></table></figure><h5 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker compose"></a>Docker compose</h5><blockquote><p>docker-compose 是官方开源项目，负责实现对 Docker 容器集群的快速编排，部署分布式应用。通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p></blockquote><p>下载Docker Compose</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>修改该文件的权限为可执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker-compose version%查看是否成功<br></code></pre></td></tr></table></figure><p>一般使用步骤</p><p>1、创建一个空目录。<br>2、定义 Dockerfile，方便迁移到任何地方<br>3、编写 docker-compose.yml 文件<br>4、运行 docker-compose up 启动服务、docker-compose down 关闭服务</p><p>编写docker-compose.yml文件</p><blockquote><p>Docker Compose将所管理的容器分为三层，工程、服务及容器。docker-compose.yml中定义所有服务组成了一个工程，services节点下即为服务，服务之下为容器。容器与容器直之间可以以服务名称为域名进行访问，比如在mall-tiny-docker-compose服务中可以通过jdbc:mysql:&#x2F;&#x2F;db:3306这个地址来访问db这个mysql服务。</p></blockquote><p>示例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>    <span class="hljs-comment"># 指定服务名称</span><br>    <span class="hljs-attr">db:</span><br>        <span class="hljs-comment"># 指定服务使用的镜像</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>        <span class="hljs-comment"># 指定容器名称</span><br>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>        <span class="hljs-comment"># 指定服务运行的端口</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span><br>        <span class="hljs-comment"># 指定容器中需要挂载的文件</span><br>        <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mysql/log:/var/log/mysql</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mysql/data:/var/lib/mysql</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/mysql/conf:/etc/mysql</span><br>        <span class="hljs-comment"># 指定容器的环境变量</span><br>        <span class="hljs-attr">environment:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD=root</span><br>    <span class="hljs-comment"># 指定服务名称</span><br>    <span class="hljs-attr">mall-tiny-docker-compose:</span><br>        <span class="hljs-comment"># 指定服务使用的镜像</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">mall-tiny/mall-tiny-docker-compose:0.0.1-SNAPSHOT</span><br>        <span class="hljs-comment"># 指定容器名称</span><br>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">mall-tiny-docker-compose</span><br>        <span class="hljs-comment"># 指定服务运行的端口</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>        <span class="hljs-comment"># 指定容器中需要挂载的文件</span><br>        <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/mydata/app/mall-tiny-docker-compose/logs:/var/logs</span><br></code></pre></td></tr></table></figure><hr><h2 id="Docker问题排查"><a href="#Docker问题排查" class="headerlink" title="Docker问题排查:"></a>Docker问题排查:</h2><p>问题发现:<br>发版时构建失败(不稳定),<br>问题分析:<br>构建编译打包阶段命令执行成功,目标服务器build命令或run命令出问题.<br>目标服务器中直接执行命令,报磁盘空间不足, 具体分析发现docker目录下磁盘占用非常大</p><p>分析磁盘占用参考命令:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.查看大文件命令：find . -size +500M （只适合当前目录）  <br>​  <br>2.du -sh : 查看当前目录总共占的容量。不单独列出各子项占用的容量  <br>​  <br>3.df -h：查看整体磁盘使用情况、  <br>​  <br>4.du -lh --max-depth=1 : 查看当前目录下一级子文件和子目录占用的磁盘容量。  <br>​  <br>5.find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr  查找&quot;/&quot;目录下所有大于100M的所有文件<br></code></pre></td></tr></table></figure><p>有效信息如下: 通过查看,主要是 docker目录下vfs文件夹很大</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@localhost ~]# cd /home/docker  <br>[root@localhost docker]# du -lh --max-depth=1  <br>104M    ./containers  <br>0       ./plugins  <br>198G    ./vfs  <br>12M     ./image  <br>24K     ./volumes  <br>96K     ./network  <br>0       ./swarm  <br>7.6M    ./buildkit  <br>0       ./tmp  <br>0       ./runtimes  <br>199G    .  <br>​<br></code></pre></td></tr></table></figure><p>思考过程, 多台相同配置, 环境类似的服务器, 仅这一个有次问题, 要对比一下docker配置差异.</p><p>对比 docker info发现差异<br>Storage Driver: devicemapper<br>Storage Driver: vfs</p><p>Storage Driver 不同, 并且 Storage Driver配置为 vfs, 此文件夹会随着时间很快被占用.</p><p>临时解决方案如下:</p><p>docker system prune -a    清理 docker 容器</p><p>暂定方案:</p><p>编辑daemon.json追加配置修改storage-driver<br>vi &#x2F;etc&#x2F;docker&#x2F;daemon.json  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;,&quot;http://hub-mirror.c.163.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;],<br> &quot;storage-driver&quot;:&quot;devicemapper&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>扩展:</p><p>1,docker安装方式相同, 并且在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service和 &#x2F;etc&#x2F;docker&#x2F;daemon.json 都没有发现相关额外配置,为啥Storage Driver的默认配置会不同? 是与版本差异么?</p><p>一个是23.0.1 一个是 20.10.17</p><p>2,Storage Driver的vfs模式, 明细感觉对磁盘的利用方式不一样,有何优势?</p><blockquote><p>2.1 Docker Storage Driver的devicemapper和vfs模式是两种不同的存储驱动程序，它们各自具有一些优势和特点。<br>Devicemapper是一种高级存储管理器，它使用了Linux内核提供的设备映射技术。它的优势在于支持高级的存储功能，如快照和克隆。Devicemapper还可以使用不同的存储池来管理容器的镜像和数据，提供了更好的隔离性和可管理性。然而，使用Devicemapper可能需要更多的配置和管理工作，并且在处理大量写入操作时可能会出现性能瓶颈。<br>VFS（Virtual File System）是Docker的默认存储驱动程序，它直接使用主机操作系统的文件系统来管理容器的镜像和数据。VFS的优势在于简单易用，无需额外的配置和管理。它适用于开发和测试环境，但在生产环境中可能会遇到性能和可扩展性方面的限制。 综上所述，Devicemapper适用于需要高级存储功能和更好隔离性的场景，但需要更多的配置和管理。而VFS适用于简单的开发和测试环境。选择哪种存储驱动程序取决于您的具体需求和环境。</p><p>2.2 在多次构建镜像后，Devicemapper对主机磁盘的占用较少，而VFS占用较多的原因是它们的存储机制不同。<br>Devicemapper使用了写时复制（Copy-on-Write）的机制。当使用Devicemapper构建镜像时，它会创建一个基础镜像和一个写入层。每次构建镜像时，只有更改的部分会被写入到写入层，而不会对基础镜像进行修改。这样可以节省磁盘空间，因为多个镜像可以共享相同的基础层。因此，Devicemapper对主机磁盘的占用相对较少。 相反，VFS直接使用主机操作系统的文件系统来管理镜像和数据。每次构建镜像时，VFS会在主机文件系统上创建一个完整的镜像副本，包括所有的更改和文件。这导致每个构建都会占用更多的磁盘空间，因为每个镜像都是完整的副本。 因此，如果您需要在多次构建镜像后节省磁盘空间，Devicemapper可能是更好的选择。但请注意，Devicemapper可能需要更多的配置和管理工作，并且在处理大量写入操作时可能会出现性能瓶颈</p></blockquote><p>3,网上有主动指定vfs模式的配置教程,相关参数具体作用是什么?</p><p>{<br>  “storage-driver”: “vfs”,<br>  “storage-opts”: [“size&#x3D;256M”]<br>}</p><hr><p>2024年8月6日14:00:00<br>Linux虚拟机 yum update报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Loading mirror speeds from cached hostfile<br>Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was<br>14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; 未知的错误&quot;<br><br><br> One of the configured repositories failed (未知),<br> and yum doesn&#x27;t have enough cached data to continue. At this point the only<br> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:<br><br>     1. Contact the upstream for the repository and get them to fix the problem.<br><br>     2. Reconfigure the baseurl/etc. for the repository, to point to a working<br>        upstream. This is most often useful if you are using a newer<br>        distribution release than is supported by the repository (and the<br>        packages for the previous distribution release still work).<br><br>     3. Run the command with the repository temporarily disabled<br>            yum --disablerepo=&lt;repoid&gt; ...<br><br>     4. Disable the repository permanently, so yum won&#x27;t use it by default. Yum<br>        will then just ignore the repository until you permanently enable it<br>        again or use --enablerepo for temporary usage:<br><br>            yum-config-manager --disable &lt;repoid&gt;<br>        or<br>            subscription-manager repos --disable=&lt;repoid&gt;<br><br>     5. Configure the failing repository to be skipped, if it is unavailable.<br>        Note that yum will try to contact the repo. when it runs most commands,<br>        so will have to try and fail each time (and thus. yum will be be much<br>        slower). If it is a very temporary problem though, this is often a nice<br>        compromise:<br><br>            yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=true<br><br>Cannot find a valid baseurl for repo: base/7/x86_64<br><br></code></pre></td></tr></table></figure><p>经过排查，虚拟机可访问外网，但还是是用不了yum命令，说明是yum镜像没有了，那么就得下载一个来更新。<br>在安装完CentOS后一般需要修改yum源，才能够在安装更新rpm包时获得比较理想的速度。国内比较快的有阿里源、163源。这里以阿里源为例子。</p><ol><li>cd &#x2F;etc&#x2F;yum.repos.d</li><li>mv CentOS-Base.repo CentOS-Base.repo.backup</li><li>wget <a href="https://mirrors.aliyun.com/repo/Centos-7.repo">https://mirrors.aliyun.com/repo/Centos-7.repo</a></li><li>mv Centos-7.repo CentOS-Base.repo</li><li>yum clean all</li></ol>]]></content>
      
      
      <categories>
          
          <category> 使用记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软实力没有好教材，硬实力全是好教材</title>
      <link href="/2017/03/04/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02017%E5%B9%B43%E6%9C%8814%E6%97%A5/"/>
      <url>/2017/03/04/%E5%BF%83%E6%83%85%E9%9A%8F%E8%AE%B0/%E9%9A%8F%E8%AE%B02017%E5%B9%B43%E6%9C%8814%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="软实力没有好教材，硬实力全是好教材"><a href="#软实力没有好教材，硬实力全是好教材" class="headerlink" title="软实力没有好教材，硬实力全是好教材"></a>软实力没有好教材，硬实力全是好教材</h1><p>引用：如果要具体给到一个切入点，那么建议：</p><p>1、从基础的C语言开始，然后学习算法，走科班路线；</p><p>2、从网页制作开始，然后学习网站工程，走产品路线，这是编程中最好入门的了；不管是Java、python、php这类后端开发，还是iOS、Android、WP这类移动开发，抑或是前端开发，对网页制作的掌握都是少不了的。</p><p>不必太担心学错，因为到达工程级别，你学过的八成知识都不会被作为工具使用，而它们的只是实现了它们的历史使命——成为你现有某个实用知识的中间点&#x2F;桥梁、为你现在的学习效率做了一次铺垫。</p><p>首先吧，别想速成。这要能速成，那么专业人士不就该喝西北风去了？</p><p>所以要真解决了学习范围的问题后，你下一个问题应该是“要实现**应该具备那些知识”一类的了。等你在某个点扎根后，想的就是利用这个学习能力，去另一个自己更喜欢的领域，还是就此为据点扩充范围，亦或者深入这个领域（也是扩充的一种吧，方向不同）。</p><p>明知道很烂的方法（方式），即便是能达到效果，也不要重复使用，避免养成习惯。</p>]]></content>
      
      
      <categories>
          
          <category> 心情随记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
